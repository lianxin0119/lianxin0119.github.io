<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git的使用和基本原理</title>
    <url>/2021/03/14/Git/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>　　版本控制系统<code>VCS(Version Control System)</code>，是一种用于管理控制代码版本的工具系统，通过该种系统能够实现对代码的追踪维护等功能。目前在使用的主流系统中，主要有以下两种：</p>
<ul>
<li><strong>集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)</strong></li>
</ul>
<p>　　该类系统的主要的运作流程是，由单一的服务器承担中央仓库的角色，保存代码修订的所有版本及记录。然后各个协同人员通过拉取和推送代码进行协作开发，协同人员本地只需要留存需要修改的指定代码版本。这种做法对于早期靠着本地数据库维护的代码版本控制系统来说，管理员能更加清晰的了解到协同开发人员每次的修改及对他们的权限控制。当然，这样的系统也是存在一些致命的弱点的，单一的服务器作为最主要的角色，一旦出现了问题，那么所有连接服务器的客户端都无法提交或者更新代码，如果更严重一些，服务器的磁盘出了问题，整个工程的代码及代码历史都会丢失。国内一般使用是的 <code>SVN</code>，现在依然有一些企业使用的是这种管理工具。</p>
<ul>
<li><strong>分布化的版本控制系统(Distributed Version Control System，简称 DVCS)</strong></li>
</ul>
<p>　　为了解决集中化的版本控制系统所存在的隐患问题，分布式的版本控制系统就面世了，如<code>Git、Mercurial、Bazaar 以及 Darcs</code>等。其最明显与集中化系统的区别就是，在分布式的系统中，每一个客户端都保存有完整的修订历史记录的快照。这样每次代码修改的操作，都是其他客户端进行了一些代码仓库快照的备份，当某一个仓库出现问题时，可以通过其他仓库的完整记录来进行恢复。这里可能有一个疑问，就是每个客户端都保存有完整的修改历史仓库，那每一份仓库会不会都很大，对各个协同的人员来说，同步与备份或者本地的存储等有一定的压力。事实上，除去资源文件，代码的修订记录的大小是很可观的，同时，<code>git</code>中也针对这些进行了一定的优化，在同步与本地的存储上，实际使用的体验的还是很可观的。所以，如果项目中的资源文件较大时，依然可以考虑使用中央式的版本控制系统来进行管理。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>　　一般来说，开始使用<code>git</code>的场景分为从远程服务器克隆已存在的项目和开始新项目，初始化仓库。前者直接使用<code>git clone XXXXX(远程仓库地址)</code>就可以将远端的仓库完整的拷贝到本地。</p>
<p><img src="https://i.loli.net/2021/03/14/FzLnCqGV3HK97sM.jpg" alt="克隆代码"></p>
<p>　　不过从头开始初始化一个本地仓库，更容易去理解<code>git</code>的工作流程。命令<code>git init</code>可以将一个文件目录初始化为一个仓库， <code>git</code>会相应的生成一个<code>.git</code>的文件夹，这个文件夹就是 <strong>本地仓库（Local Repository）</strong>，这个文件夹中就会保存该目录中<strong>之后</strong>所有文件的改动记录，而这个目录在<code>git</code>中就被称为<code>工作区(Working Directory)</code>。</p>
<p><img src="https://i.loli.net/2021/03/14/xnK7UeGZ5kfhaqr.png" alt="git初始化"></p>
<p>　　除了<code>工作区</code>以外，<code>git</code>中还有<code>暂存区</code>。(注意：这里我是新建了一个文件夹，进行的初始化操作，如果新建的文件夹是刚刚克隆的<code>git</code>目录中，在已存在的仓库中再次<code>git init</code>一个仓库会不会有什么问题，答案是并不会，<code>git</code>中使用的是目录管理而不是设备管理，一个仓库只会对应的管理其对应的目录，不会相互影响)</p>
<p><img src="https://i.loli.net/2021/03/14/SNioDXVbxvuayE6.png" alt="git工作流程"></p>
<p>　　如上图，是<code>git</code>的一个基本的工作流程：当我们在工作区域中修改了某个文件的文件内容时，<code>git</code>会自动检测到这种改动并进行了标记，然后需要我们手动的将这些改动添加(使用命令 <code>git add</code>)到暂存区中，这样我们所修改的东西就会被<code>git</code>记录下来，而没有添加到暂存区的改动在进行各种<code>git</code>命令时可能会丢失（例如切换分支等。）。如果我们确定了暂存区中的内容是这样的修改，就可以将暂存区的改动记录进行提交，那么这次修改的内容就会从暂存区迁移到仓库中，并在仓库中生成一个提交记录–<code>commit</code>。整个仓库中，所有的改动记录就是有一个一个的<code>commit</code>串行所构成的。以下就是文件在不同的区域的一个时序图：</p>
<p><img src="https://i.loli.net/2021/03/14/iyjF6OocCxg3bnM.jpg" alt="git时序图"></p>
<p>　　这里的checkout可以将任意一次的<code>commit</code>代码拿出来作为一个工作区。然后进行修改。所以我们应当要求每一个<code>commit</code>都是可运行的，没有预期之外错误的一个代码结点。也应该要求commit时是要写好message。方便checkout和查找历史记录。</p>
<p>回到我们刚刚克隆的仓库中，使用命令<code>git log</code>可以查看当前仓库的一些日志。这里我还贴在Android Studio中的查看方式。</p>
<p><img src="https://i.loli.net/2021/03/14/duk2VIASaTpxyzg.png" alt="git日志-Android Studio"></p>
<p><img src="https://i.loli.net/2021/03/14/3d71JykpGaFNo85.png" alt="git日志"></p>
<p>　　分析图中出现的数据，就衍生出来 <code>git</code> 中的几个重要的概念：</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>　　简单来说，<code>git</code>中的引用就是指向某个<code>commit</code>的快捷方式，我们通过操作引用能够快速的操作到某个具体的<code>commit</code>，可以看到上图中的内容，记录中显示，远端仓库有多次<code>commit</code>，每一次的<code>commit</code>的后面跟着一串字符串，这个字符串是根据该<code>commit</code>计算出来的<code>SHA-1</code>值(一种算法计算出来的值，两个 <code>commit</code> 计算出来的值很少能重复)，<code>commit</code>将其作为唯一的标识。大多数时候，我们需要操作具体的某个<code>commit</code>时，可以直接使用该值的前几位来代表这个<code>commit</code>（一般来说是6-8位，github使用的是7位，Android Studio使用的8位），如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 9fb106</span><br></pre></td></tr></table></figure>

<p>在Android Studio中直接右键<code>commit</code>然后选择checkout Revision就会签出选中的<code>commit</code>。</p>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>　　这个引用比较特殊，它指的是<strong>指向当前<code>commit</code>的引用</strong>，当我们从远端仓库拉取代码时或者<code>checkout</code>新的分支时，<code>HEAD</code>指向会随着我们的操作相应的修改，使得它始终指向的是当前<strong>工作区</strong>中对应的<code>commit</code>。</p>
<h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>　　这个是<code>git</code>在创建时，默认生成的一个分支。大多数工程都将该分支作为主分支使用，在开发时，建立其他分支来开发工作，最后将完善的功能合并到主分支中。上图中的<code>origin/develop</code>代表的是远程仓库的<code>develop</code>分支。<code>HEAD</code>指向的<code>commit</code>是<code>9fb106</code>，值得一提的是，无论本地的<code>HEAD</code>如何修改，远程仓库中的<code>HEAD</code>永远指向的是<code>master</code>分支。</p>
<h4 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h4><p>　　分支，既然有默认的分支，那也代表我们可以创建其他分支。其实，在整个<code>git</code>仓库中，是由一个个的分支构成，而分支由一个个的<code>commit</code>构成。形象一点说就是<code>git</code>仓库像一颗大树，<code>master</code>分支就是大树成长时的主干，慢慢随着长大，出现了许多的树枝，这些树枝就是我们自己新建的<code>branch</code>，而树枝上的树叶就是一个个<code>commit</code>。</p>
<p>　　当<code>HEAD</code>指向某个<code>branch</code>时，其实<strong>间接的</strong>是指向这个<code>branch</code>的某个<code>commit</code>(之所以说是间接的指向，是因为这种情况下的<code>HEAD</code>还是直接指向的<code>branch</code>，而<code>branch</code>指向的是它最新的<code>commit</code>，这样构成了间接的指向。还有直接的指向，就是使用<code>git checkout --detach</code>命令后，<code>HEAD</code>就会由指向<code>branch</code>变成指向<code>commit</code>)。如下所示:</p>
<p><img src="https://i.loli.net/2021/03/14/jJratZHKGBkTCN2.jpg" alt="git Head指向"></p>
<p>　　<code>git checkout xxx</code>这个命令为 签出，使用该命令签出某个<code>commit</code>时，工作区的内容会替换为该<code>commit</code>，并同时将 <code>HEAD</code> 引用指向该<code>commit</code>，当签出命令为某个分支时，会签出该分支的最新的那个<code>commit</code>。<code>branch</code>的构成是一条从起始<code>commit</code>到该branch最新的<code>commit</code>的一条路径，它所包含的信息就是这条<code>commit</code>链上所有的<code>commit</code>。</p>
<h3 id="基本流程中的操作"><a href="#基本流程中的操作" class="headerlink" title="基本流程中的操作"></a>基本流程中的操作</h3><h4 id="流程操作"><a href="#流程操作" class="headerlink" title="流程操作"></a>流程操作</h4><p>　　假设现在我们对于文件的修改已经完成。我们可以使用<code>git status</code>命令来查看当前的一些状态。git对修改的文件进行了标识，显示为红色的 modified，红色的意思是代表这些改动还没有被添加到暂存区中，也就是处于一种被标记了，但是没有被记录的状态。然后执行<code>git add .</code>，将修改添加到暂存区中，再次使用<code>git status</code>命令来查看。刚才被标记为红色的现在变成了绿色。表示本次改的被添加到了暂存区中。</p>
<p>　　最后使用<code>git commit -m &quot;本次提交的描述&quot;</code>命令可以将暂存区中的改动记录提交到仓库中，<code>HEAD</code>也指向了刚刚提交的最新的<code>commit</code>。但是需要注意的是，我们提交的仓库是本地仓库。也就是只有我们自己知道本次修改，而其他人都不知道本次修改。为了让别人知道本次修改我们需要将它推到远端。但是正常情况下，我们其实并不知道远端是否有新的改动，所以一个比较保险的做法，先进行一次拉取操作<code>git pull</code>，这样如果远端有人提交了改动，我们就能先拉取合并。再把最后合并通过<code>git push</code>推到远端仓库。Android Studio可视化操作很简单就不多赘述。</p>
<p>　　这算是一次比较顺利的工作流程，从本地修改文件，然后提交记录，再推送到远端进行了合并，以方便其他同事拉取你的修改。但是大多数情况下，并不会这么顺利，会产生比较多的冲突。</p>
<h4 id="关于CLONE"><a href="#关于CLONE" class="headerlink" title="关于CLONE"></a>关于CLONE</h4><p>　　当我们使用<code>git clone</code>的命令时，<code>git</code>首先是将远程仓库的快照下载到本地。然后根据快照中的分支和<code>commit</code>去下载对应的<code>commit</code>。然后<code>git</code>会从第一个起点的<code>commit</code>开始，一个一个的应用<code>commit</code>链上的<code>commit</code>到工作区中，直到最新的那个<code>commit</code>被应用上。</p>
<h4 id="关于-ADD"><a href="#关于-ADD" class="headerlink" title="关于 ADD"></a>关于 ADD</h4><p>　　刚刚的流程中使用了<code>add</code>命令，我使用的是<code>git add .</code>后面跟了一个<code>.</code>这个的意思是，<strong>全部暂存</strong>。如果你不想全部暂存，就需要把<code>.</code>替换成需要暂存的<strong>文件名</strong>。我们在工作区中，新增的文件，默认是不会被<code>git</code>所追踪的，也就说文件中任何的改动是不被<code>git</code>检测记录的。需要使用<code>git add</code>命令将文件添加，这样<code>git</code>才会开始追踪，所以新增一个文件时，使用<code>add</code>命令的含义其实有两层，一个将这个文件的新增作为工作区中的一种形式的改动，提交到<code>git</code>仓库中，第二层就是让文件被<code>git</code>所追踪。其他时候，当我们做出一些修改的时候，需要添加到暂存区中，也是使用此命令。</p>
<p>　　需要注意的一点是，<code>git</code>中所记录的是文件内容的改动，而非文件本身，所以当添加了一次文件的修改后，又修改了相同文件的内容，还需要再添加一次刚刚的修改。如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动了文本的内容</span><br><span class="line"># ------------</span><br><span class="line"># 添加到暂存区</span><br><span class="line">git add . </span><br><span class="line"># 再次改动文本的内容</span><br><span class="line"># ------------</span><br><span class="line"># 注意这里还需要添加刚刚改动的内容到暂存区中</span><br><span class="line">git add .</span><br><span class="line"># 这样两次改动才会都被仓库记录</span><br></pre></td></tr></table></figure>

<h4 id="关于-PULL"><a href="#关于-PULL" class="headerlink" title="关于 PULL"></a>关于 PULL</h4><p>　　<code>git pull</code>操作其实就做了两件事，先将远端的<code>commits</code>拉取到本地，然后进行一次合并操作。</p>
<h4 id="关于-PUSH"><a href="#关于-PUSH" class="headerlink" title="关于 PUSH"></a>关于 PUSH</h4><p>　　刚刚的操作中，使用<code>git push</code>就将<code>master</code>分支上新的<code>commit</code>推到了远端仓库，与远端仓库的<code>master</code>分支进行了合并。这其实是一种粗略的说法，一笔带过了。</p>
<p>　　<code>git push</code> 会将默认分支的本地提交记录上传到远程分支上进行合并，如果不指定的话，所更新的分支为<code>git config 中的 push.default的值对应的分支，这个值默认为:current</code> 其中的值<code>git config</code> 命令来进行修改， 进而改变 push 时的行为，详情查看<a href="https://git-scm.com/docs/git-config#git-config-pushdefault">git config</a>。如果需要提交记录的分支不是默认的分支，需要在命令中添加几个新的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin target_feature</span><br></pre></td></tr></table></figure>

<p>那么这次的 push 会推向远程分支的<code>target_feature</code>分支。</p>
<p><strong>注意：push 时不会上传 HEAD 的指向，远程分支的 HEAD 永远指向的是 <code>master</code></strong></p>
<h3 id="分支相关的操作"><a href="#分支相关的操作" class="headerlink" title="分支相关的操作"></a>分支相关的操作</h3><h4 id="分支的创建和删除"><a href="#分支的创建和删除" class="headerlink" title="分支的创建和删除"></a>分支的创建和删除</h4><ol>
<li><p>创建 <code>branch</code> 的方式是 <code>git branch 名称</code> 或 <code>git checkout -b 名称</code>（创建后自动切换）；</p>
</li>
<li><p>切换的方式是 <code>git checkout 名称</code>；</p>
</li>
<li><p>删除的方式是 <code>git branch -d 名称</code>。</p>
</li>
</ol>
<h4 id="分支的合并-Merge"><a href="#分支的合并-Merge" class="headerlink" title="分支的合并 Merge"></a>分支的合并 Merge</h4><p>　　多数情况下，我们需要将不同的分支的代码进行合并，那么就需要使用到<code>git merge</code>命令，该命令具体做的事情是：<strong>从目标 <code>commit</code> 和当前 <code>commit</code> （即 <code>HEAD</code>所指向的 <code>commit</code>）分叉的位置起，把目标 <code>commit</code> 的路径上的所有 <code>commit</code> 的内容一并应用到当前 <code>commit</code>，然后自动生成一个新的 <code>commit</code>。</strong>在合并时，最舒服的状态就是，新的分支的改动是领先于合并的分支的，这时候只需要将新分支的<code>commits</code>直接移过来，就完成了一次合并，在<code>git</code>中被叫做<code>fast-forward</code>。不过大多数时候，还是不那么舒服的。</p>
<ul>
<li><p><strong>解决冲突</strong></p>
<p>　　同一文件，在不同的分支上都进行了改动，对于<code>git</code> 而言，可以分为良性情况和恶性情况(<code>git</code>中没有这个定义，只是为了理解)。什么是良性的呢，就是两次改动的地方不一样，比如有5行文本，<code>branch1</code>分支中改下了第4行，而<code>master</code>分支中修改了第3行，这样<code>git</code>就能知道两个分支改的东西不一样，就能自动合并，最后新生成的<code>commit</code>就是第3行和第4行都被修改了。对应来说，恶性的就是两个分支的改动，改了同一处地方，<code>git</code>并不知道哪个分支的改动才是我们想要的，所以最后的决定权交到了我们自己手里，这个时候就需要手动的处理冲突。<br>  　　<br>  　　在git中，对于这种冲突，会做一些明显的标识如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; HEAD</span><br><span class="line">第4行内容master分支的修改</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">第4行内容 branch1分支的修改</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch1</span><br></pre></td></tr></table></figure>

<p>这个很容易理解，上面的内容是<code>HEAD</code>所在的<code>master</code>分支的修改，下面的是    <code>branch1</code>分支的修改，我们根据具体的需求进行修改，删除<code>git</code>自动生成的<code>&gt;&gt;&gt;&gt;&gt;</code>和<code>======</code>。这算一次新的改动了，所以需要再次进行<code>add .</code>和<code>commit</code>。</p>
</li>
<li><p><strong>不解决冲突</strong></p>
<p>上诉的操作代表正常处理了一次冲突，如果不需要处理，想要放弃。可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure>

<p>之后便回到 <code>merge</code> 前的状态。如图所示，在合并时，产生了冲突，执行命令后，状态回到了<code>master</code>合并之前。</p>
</li>
</ul>
<h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><h4 id="临时暂存"><a href="#临时暂存" class="headerlink" title="临时暂存"></a>临时暂存</h4><p>　　有时候，在不同分支工作时，需要偶尔切到其他分支看一行代码，或者调试个 BUG啥的，我们都是提交一个临时的<code>commit</code>再去切，这样算是一个保险的做法。还有更优雅一点的做法就是<code>git stash</code>命令，这个命令可以将目前工作区的改动都临时保存在一个独立的地方，等你搞好了其他的工作，再回来时，使用<code>git stash pop</code>就可以恢复了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：没有被 track 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 <code>-u</code> 参数，它是 <code>--include-untracked</code> 的简写。</p>
</blockquote>
<p>在Android studio中这样操作：</p>
<p><img src="https://i.loli.net/2021/03/14/fwmlEBuSV9WQqPc.png" alt="git缓存区"></p>
<p>需要注意的是在pop时需要勾选<code>Pop stash</code>，否者你保存的stash会一直存在栈中。</p>
<h4 id="Tag的使用"><a href="#Tag的使用" class="headerlink" title="Tag的使用"></a>Tag的使用</h4><p>　　<code>tag</code>就是标签，当我们在一个分支上构建了不同版本的应用时，可以通过<code>tag</code>来进行标记。这是一种基础的用法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0.0 -m &#39;xxx build version&#39;</span><br></pre></td></tr></table></figure>

<p>　　其实，<code>git</code> 的<code>tag</code>还可以用于自动化的构建和测试当中，本地打好了<code>tag</code>后，推送到远端仓库，在远端仓库中部署<code>CI</code>等自动化的脚本，可以检测到相应的<code>tag</code>来进行一系列的自动化操作。但是这个更多的是自动化构建方面的知识，有兴趣可以了解了解。</p>
<blockquote>
<p><a href="http://kescoode.com/travis-ci-android-github-release/"> 用TRAVIS CI给Android项目部署Github Release </a></p>
</blockquote>
<h4 id="恢复已删除的分支"><a href="#恢复已删除的分支" class="headerlink" title="恢复已删除的分支"></a>恢复已删除的分支</h4><p>　　有时候，不管有意无意，都可能误删了分支，<strong>一定要及时找回</strong>。操作步骤如下：</p>
<ol>
<li><p>使用<code>git reflog</code>命令查看<code>HEAD</code>移动的相关记录，这个记录最新的在最上面，找到与<code>branch1</code>相关的记录，如图，找到最后一次从<code>branch1</code>移动到<code>master</code>的记录，那么这条记录之前的<code>commit</code>肯定是<code>branch1</code>上的一条<code>commit</code>。</p>
<p><img src="https://i.loli.net/2021/03/14/obXlveiYwNpCQP8.png" alt="git历史commit"></p>
</li>
<li><p>签出这个<code>commit</code>，并在该<code>commit</code>上建立之前误删的分支即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout ec651f2</span><br></pre></td></tr></table></figure>

<p>依然需要注意的一点：<code>git</code>会定期回收无引用的<code>commit</code>，所以这个操作需要及时。</p>
</li>
</ol>
<h4 id="仅合并少数几个-commit"><a href="#仅合并少数几个-commit" class="headerlink" title="仅合并少数几个 commit"></a>仅合并少数几个 commit</h4><p>　　在实际工作开发中，会遵循标准的 Git Work flow，对待不同的功能，会切出不同的分支进行 开发，所以，基于什么基准分支切出来的功能分支进行 开发，这是一个很重要的问题。</p>
<p>　　如果切错了基准分支，你会发现可能最终开发完成之后， merge 不回去了。或者需要将某个分支上的 commit 代码，移植到某个分支上面，就需要使用到 cherry-pick 这个 git 命令了。</p>
<p>这个命令的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick -x &lt;commit_id&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>-x</code>的参数代表保留原提交者的信息，后面的<code>&lt;commit_id&gt;</code>的写法就是<code>&lt;start-commit-id&gt;…&lt;end-commit-id&gt;</code>这个代表一个从startCommitId到endCommitId的一个左开右闭的区别<code>(startId, endId]</code>，如果需要包含startId可以添加一个符号<code>&lt;start-commit-id&gt;^…&lt;end-commit-id&gt;</code>这样就是<code>[startId,endID]</code>的一个闭区间了。</p>
<p>　　合并过程中，如果出现了冲突，就和普通冲突一样，手动的解决，然后添加提交，再执行git cherry-pick –continue就可以继续了，直到合并完成。</p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903479421435918">Cherry-Pick | 一日一 Git</a></p>
</blockquote>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>　　Git远比我想象的强大很多，也是在学习的时候才发现他拥有的功能很多，我所讲解的也只是冰山一角。还有诸如<strong>rebase 与 merge，修正已提交的 Commit(不是最新的也可以修改)，丢弃 commit(不是最新的也可以丢弃)，修改已经 Push 的 commit</strong>等许多我都没有讲到。后面学习又在记录这些。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin协程-使用篇</title>
    <url>/2023/03/12/Coroutine/</url>
    <content><![CDATA[<p>　　在阅读之前，我认为你对与Kotlin的操作符重载、高阶函数、扩展函数以及多线程都有一定的了解认识，在这个基础之上我们进行协程的学习。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　协程（Coroutines）不是Kotlin独有的，也不是Kotlin提出来的新概念，它早在1958年就被发明并且用于构建汇编程序。这说明协程是一种<strong>编程思想</strong>，并不局限于某种特定的语言。其他的一些编程语言，如Go、Python等都可以在语言层面上实现协程，甚至是Java也可以通过扩展库实现协程。网上对于协程的定义也有很多：</p>
<ul>
<li>协程是轻量级线程（官方文档）</li>
<li>协程运行在用户态，线程运行在内核态</li>
<li>协程是协作式的，线程是抢占式的</li>
<li>协程是一套线程框架（扔物线的表述）</li>
</ul>
<p>　　上诉定义的差异是看待协程的角度是不同，而我们作为一个Android开发者，要理解Kotlin协程，应该从一个Android开发者的角度来理解协程。协程虽然并不直接和操作系统打交道，但是协程是运行在线程之中，依赖于线程的。不过协程的挂起是<strong>不需要阻塞线程，几乎无代价并且是由开发者控制的</strong>。所以说协程更像是用户态的线程。</p>
<p>　　对比一个进程可以创建多个线程一样，一个线程是可以创建多个协程的。并且同一个线程的协程切换是没有开销的。它的设计初衷是<strong>为了解决多并发和并发之间的协作</strong>问题，程序的逻辑可以在协程中顺序的表达，而底层库为我们去解决异步性。简单来说就是<strong>以顺序的编码去实现异步执行的代码</strong>。这样听起来协程和线程的作用差不多类似，在官方文档的介绍中也可以看到协程和线程的对比实现。因此我们可以带入线程的角度去理解协程。</p>
<p>　　总而言之：协程可以简化异步编程，可以顺序的表达程序。它提供了一种避免阻塞线程并且更廉价、更可控的操作替代线程阻塞的方法-<strong>协程挂起</strong>。</p>
<p>　　<strong>挂起</strong>是协程中一个很重要的理念。</p>
<h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>　　我们可以先说一说使用协程在Android开发中的优势，但是我们现在不一定要全部理解这些优势，因为在后面介绍和使用中，我们自己也能总结出来协程的优势。现在有个大概印象就好。</p>
<ul>
<li><p><strong>很容易切换到子线程</strong></p>
<p>我们有许多方法可以让操作远离主线程，<code>ExecutorServices</code>、<code>AsyncTask</code>、<code>Loaders</code>等等，但都不如协程来的轻松，并且在处理业务逻辑时可以顺序书写代码，没有累人的回调。</p>
</li>
<li><p><strong>协程是挂起式的而不是阻塞式的</strong></p>
<p>挂起函数挂起协程时，不会阻塞协程所在的线程，它会将自己先从线程中脱离出去，让线程去干其他的事情。挂起函数执行完成后会自动恢复协程，后面的代码才会继续执行。</p>
</li>
<li><p><strong>编译器会检测调用</strong></p>
<p>当一个挂起函数被调用时，编译器会检测该函数的调用环境是否是一个协程上下文的环境。</p>
</li>
<li><p><strong>结构化并发</strong></p>
<p>想象一种情况，我们进一个页面需要连续请求几个接口，当其中一个网络请求出错时或者此时退出页面，我们希望关闭其他并行的网络请求。如果用Rx实现，则需要使用zip操作符进行合并请求，然后持有zip返回的对象，在<code>destory</code>的时候销毁。然而协程只需要你取消持有的最顶层上下文，那么其所有的上下文就都会被取消。</p>
<p>如果一个接口需要依赖另一个接口返回的结果同样会很麻烦。</p>
</li>
<li><p><strong>协程是轻量级的</strong></p>
<p>我们可以很轻松的创建十万个协程，但是创建十万个线程（会OOM）基本不现实。</p>
</li>
</ul>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>　　这里所说的重要概念和上面说的优势一样，现在只需要有个大致印象就OK。在了解完使用之后会进行详细介绍。</p>
<ul>
<li><code>CoroutineScope</code></li>
</ul>
<p>　　协程作用域（<code>CoroutineScope</code>），可以理解为协程本身。包含了协程上下文（<code>CoroutineContext</code>）。<strong>每个协程构建器(如<code>launch</code>、<code>async</code>等)都是<code>CoroutineScope</code>的扩展</strong>，并继承其<code>coroutineContext</code>以自动传播其所有元素和取消。获得作用域的独立实例的最佳方法是<code>CoroutineScope()</code>和<code>MainScope()</code>工厂函数(这两个函数是top-level函数)，注意在不再需要这些协程作用域时要取消它们。可以使用<strong>加号操作符</strong>将其它上下文元素追加到作用域。（官方表述）</p>
<ul>
<li><code>CoroutineContext</code></li>
</ul>
<p>　　协程上下文（<code>CoroutineContext</code>）是一些元素的集合，主要包括<code>Job</code>和<code>CoroutineDispatcher</code>元素。可以代表一个协程具体的运行场景。</p>
<ul>
<li><code>CoroutineDispatcher</code></li>
</ul>
<p>　　协程调度器（<code>CoroutineDispatcher</code>）决定协程所在的线程或者线程池。如果不指定调度器，就会在当前线程运行。目前提供了四种默认实现，<code>Dispatchers.Default</code>、<code>Dispatchers.IO</code>、<code>Dispatchers.Unconfined</code>、<code>Dispatchers.Main</code>。</p>
<ul>
<li><code>EmptyCoroutineContext</code></li>
</ul>
<p>　　<code>EmptyCoroutineContext</code>空的协程上下文，当存在有父协程时，使用该上下文启动一个子协程则会继承父协程的上下文，即在父协程的线程上执行代码。若不在父协程，则会在<code>Default</code>的线程池中获取编号为一的线程。</p>
<h3 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h3><p>　　为了方便观察代码运行所在的线程，我们定义一个全局的<code>log</code>函数:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(log: <span class="type">CharSequence</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> threadName = Thread.currentThread().name</span><br><span class="line">    <span class="comment">// kotlin程序就是: println(&quot;[$threadName] $log&quot;)</span></span><br><span class="line">    Log.e(<span class="string">&quot;lianxin&quot;</span>, <span class="string">&quot;[<span class="variable">$threadName</span>] <span class="variable">$log</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h4><p>　　Kotlin并没有把协程放入到标准库API当中去，而是做成了一个三方的依赖库，即使它很小。所以，我们第一步就应该把协程引入项目，需要注意的是核心库和平台库的版本需要保持一致。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心库, 必须依赖</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&#x27;</span></span><br><span class="line"><span class="comment">// Android平台库</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><p>协程需要运行在一个有协程上下文的环境中，在非协程环境中从无到有的协程创建有三种方式：</p>
<ol>
<li><p><code>runBlocking&#123;&#125;</code></p>
<p>　这是一个协程构建器，作用是在指定线程或线程池（未指定就是当前线程）创建一个新的协程，并且<strong>阻塞当前线程</strong>，直到闭包逻辑以及所有的子协程全部执行完毕，返回结果。才会继续执行后续逻辑。在项目的实际使用中<strong>不推荐</strong>使用这种创建方式，主要还是为<code>main</code>函数和单元测试设计的。</p>
</li>
<li><p><code>GlobalScope</code> + 构建器</p>
<p>　启动一个和应用生命周期一致的顶级协程，并且不会阻塞当前线程。应用生命结束时，如果协程还存在未执行完的部分会直接结束执行，所以并不能使用它保活进程，它更像是一个守护线程。</p>
<p> 因为它创建的协程是和应用生命周期一致，所以存在启动它的组件已经销毁但是协程依然存在的情况，极端情况（频繁创建销毁组件等）下可能导致资源耗尽的情况，而且由它创建的协程无法被动取消。综上，在Android的项目开发中也<strong>不推荐</strong>使用这种创建方式，除非你很明确你就是要创建顶级协程并且能够管理好它们。</p>
</li>
<li><p>实现<code>CoroutineScope</code> + 构建器</p>
<p>　既然上面的创建方式都不推荐，那这个肯定就是推荐的协程使用方式。给组件实现<code>CoroutieScope</code>接口，通过接口中的<code>CoroutineContext</code>对象去管理所有的协程。</p>
<p>协程的构建器主要是<code>launch&#123;&#125;</code>和<code>async&#123;&#125;</code>函数。<code>launch</code>返回的是<code>Job</code>对象，<code>async</code>返回的是<code>Job</code>的子类<code>Deferred</code>对象，<code>Deferred</code>额外实现了<code>await()</code>方法用于获取结果，可以阻塞线程直到获取到结果。</p>
</li>
</ol>
<h4 id="第一个协程实例"><a href="#第一个协程实例" class="headerlink" title="第一个协程实例"></a>第一个协程实例</h4><p>　　这里我们没有使用Android环境，而是直接用的kotlin项目，因为有些东西在Android环境中表现不出来。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，这里我们使用的是第二种创建方式创建的协程，我们运行一下代码（这里啰嗦一句，这个main函数就是kotlin的写法，对应了Java中的 <code>public static void main(String[] args)</code> ），可以观察到先是打印了launch，过了一秒又打印了kotlin coroutine run。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main] launch</span><br><span class="line">[main] kotlin coroutine run</span><br></pre></td></tr></table></figure>

<p>我们先看<code>GlobalScope</code>的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope</span><br></pre></td></tr></table></figure>

<p>我们发现<code>GlobalScope</code>其实是继承自<code>CoroutineScope</code>的一个对象，是由系统提供的一种默认实现。<code>delay()</code>是一个挂起函数，和<code>Thread.sleep()</code>作用有些相似。上面这个示例理解起来也不困难。我们现在把这段代码修改一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再次运行代码看看打印了什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main] launch</span><br></pre></td></tr></table></figure>

<p>你会发现只打印了launch，这是为什么呢？我们上面说了，通过<code>GlobalScope</code>创建的协程和应用生命周期一致。这里的<code>main</code>函数执行完毕，也就意味着生命结束了。自然也就打印不了kotlin coroutine run。</p>
<p>　　刚才我们是通过<code>Thread.sleep()</code>去阻塞线程等待协程完成，这里我们换成协程又该怎么去阻塞线程呢？刚好<code>runBlocking&#123;&#125;</code>会阻塞线程，那么我们就可以通过<code>runBlocking</code> + <code>delay()</code>的方式去实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    runBlocking &#123; delay(<span class="number">2000</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们能实现相同的效果，但是不推荐。同样的是如果<code>runBlocking</code>中挂起时间过短的话，依然不会打印kotlin coroutine run。</p>
<p>　　上面的示例中是因为我们知道协程运行所需要的时间，我们可以等待对应的时间让协程任务得以完成，但在实际开发的过程中我们并不知道<code>launch</code>运行需要多少时间，但是又不能无限制的等待下去。为了实现这点，我们可以利用<code>launch</code>方法返回的<code>Job</code>对象来实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job: Job = GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        job.join()</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>join()</code>函数是一个挂起函数，会挂起当前协程，等到job执行完毕才恢复执行。输出结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[main] launch</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] kotlin coroutine run</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p>　　在kotlin协程中，<code>suspend</code>是最最核心的关键字。被<code>suspend</code>修饰的函数就是挂起函数，<strong>它只能在协程或者另一个挂起函数中被调用</strong>。每当协程运行到挂起函数时会挂起当前协程。只有当挂起结束后才会回复协程并继续向下执行。这也是上一个的示例中，为什么会最后打印end。</p>
<p>　　协程挂起的对象到底是什么？是挂起线程还是别的什么？既然叫挂起函数，是不是被挂起的就是函数呢？其实都不正确，<strong>挂起的对象是协程</strong>。我们用协程构建器（诸如<code>launch</code>，<code>async</code>等）构建协程时，闭包代码块就是我们挂起的对象。当这个闭包执行到某一个<code>suspend</code>函数时，这个协程就会被挂起。</p>
<p>　　那此时又是从哪里挂起？<strong>从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离</strong>。注意，不是这个协程停下来了！是脱离，当前线程不再管这个协程要去做什么了。这个时候线程就空闲下来了，可以去执行别的任务，或者被回收掉。当协程恢复执行的时候会根据<code>CoroutineDispatcher</code>为它分配一个线程。这也就可能导致协程在挂起前后会在不同的线程上执行。</p>
<p>　　这里建议稍微停下来，思考理解一下。理解完了看下面这个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;111 start&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;111 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;222 start&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;222 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行以后可以很清晰的看到协程在调用<code>delay()</code>前后的线程不一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] 111 start</span><br><span class="line">[DefaultDispatcher-worker-1] 222 start</span><br><span class="line">[DefaultDispatcher-worker-2] 111 end</span><br><span class="line">[DefaultDispatcher-worker-4] 222 end</span><br></pre></td></tr></table></figure>

<h3 id="协程使用"><a href="#协程使用" class="headerlink" title="协程使用"></a>协程使用</h3><p>　　虽然我们上面已经使用了<code>launch</code>函数，这里也还是贴一下<code>launch</code>函数的定义，方便理解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Job</span><br></pre></td></tr></table></figure>

<h4 id="创建协程作用域"><a href="#创建协程作用域" class="headerlink" title="创建协程作用域"></a>创建协程作用域</h4><p>　　协程必须运行在协程作用域，即<code>CoroutineScope</code>之上，我们看看它的定义，它有且仅有一个成员属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在非协程环境中，通过普通方法创建协程作用域，就像下面两种方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = Job()</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Creates the main CoroutineScope for UI components.</span></span><br><span class="line">    <span class="comment">// 就是推荐在Activity等中使用</span></span><br><span class="line">    <span class="keyword">val</span> scope = MainScope()</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>CoroutineScope()</code>和<code>MainScope()</code>方法比较特别，它不是以小驼峰的命名规则去命名的，与kotlin的方法定义要求不一样，这里更像是去创建一个类的实例对象。如果看过<code>Compose</code>相关代码，应该知道这是故意为之。这两种方式都是比较常见的使用方式。</p>
<p>　　我们也可以在协程环境中通过调用<code>coroutineScope()</code>函数创建，这是一个<strong>挂起函数</strong>。它会创建一个新的协程作用域，但是它不会去启动一个新的协程。并且它也会等待所有启动的子协程全部完成后自身才会完成。它和<code>runBlocking()</code>之间最大的区别就是：前者在等待所有子协程完成其任务时不会阻塞当前线程。先看一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;job1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;out 111&quot;</span>)</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            log(<span class="string">&quot;job2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">10000</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutineScope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;out 222&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先说这个示例执行的结果是一定的，这个示例的核心点在于<code>coroutineScope</code>是一个挂起函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18:43:18.233 [main] out 111</span><br><span class="line">18:43:19.240 [main] job1</span><br><span class="line">18:43:20.239 [main] job2</span><br><span class="line">18:43:28.238 [main] coroutineScope</span><br><span class="line">18:43:28.240 [main] out 222</span><br></pre></td></tr></table></figure>

<p>我们刚才说了<code>coroutineScope</code>不会阻塞当前线程，但是现在<code>out 222</code>又在最后输出。如果你觉得<code>out 222</code>不应该在最后打印，说明还是没有完全理解协程挂起，这里本身也是一个比较难以理解的点。</p>
<p>　　分析这个原因呢？我们可以查看<code>runBlocking</code>的定义。它就是一个普通方法，调用它的线程会一直位于该函数之中，直到协程全部执行完毕。而<code>coroutineScope</code>是一个挂起函数。也就是说，如果其中的协程挂起，那么<code>coroutineScope</code>也会挂起。这样创建<code>coroutineScope</code>的外层函数就可以继续在同一线程中执行了。该线程会逃离<code>coroutineScope</code>之外，并且可以做其他的事情。</p>
<p>　　为什么要这样设计？答案无非就是进行符合结构化并发的并行分解，即将长耗时任务拆分为并发的多个短耗时任务，并等待所有并发任务完成后再返回。</p>
<h4 id="协程取消"><a href="#协程取消" class="headerlink" title="协程取消"></a>协程取消</h4><p>　　协程取消是一个非常常见的场景，我们可以通过<code>Job.cancel()</code>去取消协程。如果你只是想取消协程，这一句话就已经差不多够使用了，但是我们要了解到它更具体的原理。</p>
<p>　　协程同线程一样，也有自己的转换逻辑和生命周期：</p>
<img src="https://s2.loli.net/2023/03/12/CdcirDmwzO1ZoMT.png" alt="Coroutine_life" style="zoom:70%;" />

<p>转换逻辑如下：</p>
<img src="https://s2.loli.net/2023/03/12/6TwmNbu3MCEdfYI.png" alt="Coroutine_covert" style="zoom:100%;" />

<p>我们先举个小栗子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    log(<span class="string">&quot;start cancel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    </span><br><span class="line">    log(<span class="string">&quot;end cancel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式可以任意选择一种方式去取消，一个因为协程取消本身是一个过程，所以需要调用<code>jion()</code>等待协程取消完成。我们可以观察到日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i am 0</span><br><span class="line">[DefaultDispatcher-worker-1] i am 1</span><br><span class="line">[DefaultDispatcher-worker-1] i am 2</span><br><span class="line">[DefaultDispatcher-worker-1] start cancel</span><br><span class="line">[DefaultDispatcher-worker-1] end cancel</span><br></pre></td></tr></table></figure>

<p>这两种方式的区别在于方式1在调用<code>cancel()</code>时可以额外传递一个<code>CancellationException</code>对象。为什么传递的对象是<code>Exception</code>对象呢？我们再看一段代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(e.javaClass.simpleName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    log(<span class="string">&quot;start cancel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    </span><br><span class="line">    log(<span class="string">&quot;end cancel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行就会发现输出的结果很神奇，我们调用了<code>cancelAndJoin()</code>后，协程并没有按照预想去关闭。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-2] i am 0</span><br><span class="line">[DefaultDispatcher-worker-2] i am 1</span><br><span class="line">[DefaultDispatcher-worker-2] i am 2</span><br><span class="line">[DefaultDispatcher-worker-2] start cancel</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 3</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 4</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 5</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 6</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 7</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 8</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 9</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] end cancel</span><br></pre></td></tr></table></figure>

<p>为什么产生这种现象呢？这个段代码唯一的区别是在循环体中我用<code>try-catch</code>将<code>delay()</code>进行包裹，并将异常进行捕获，观看结果可以看到我捕获了一个异常，也正因为我们将这个异常进行捕获了，所以协程体依然会运行下去。也就是说协程的<strong>停止实际上是通过抛出特别的异常</strong>（<code>JobCancellationException</code>）来进行的，也就是说如果协程体的代码不依赖协程的cancel状态（即没有报错），则协程的取消对协程体的执行一般没什么影响。</p>
<p>　　既然我们已然知道协程是通过抛出异常来进行终止的。那如果协程正在执行一些IO操作，在取消时我们去回收释放这部分资源自然而然的就能想到使用<code>try-finally</code>这种结构去实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">10</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    log(<span class="string">&quot;start cancel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    </span><br><span class="line">    log(<span class="string">&quot;end cancel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i am 0</span><br><span class="line">[DefaultDispatcher-worker-1] i am 1</span><br><span class="line">[DefaultDispatcher-worker-1] i am 2</span><br><span class="line">[DefaultDispatcher-worker-1] start cancel</span><br><span class="line">[DefaultDispatcher-worker-2] finally is run</span><br><span class="line">[DefaultDispatcher-worker-2] end cancel</span><br></pre></td></tr></table></figure>

<p>　　在<code>kotlinx.coroutines</code>包下的所有挂起函数都是可以被取消的。他们会检查协程的取消状态，当取消协程时会抛出<code>CancellationException</code>异常。但是<strong>如果一个协程正处于某个计算过程当中，并且没有检查取消状态，那么它就是无法被取消的</strong>。我们还是通过示例来分析：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> nextTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 会在CPU上空转很多次</span></span><br><span class="line">                <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">                <span class="keyword">if</span> (now &gt;= nextTime) &#123;</span><br><span class="line">                    log(<span class="string">&quot;i is <span class="subst">$&#123;i++&#125;</span>&quot;</span>)</span><br><span class="line">                    nextTime += <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">450</span>)</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里示例代码稍微有点长，通过观察日志，我们可以发现协程并没有和我们预想的一样，在我们调用<code>cancelAndJoin()</code>之后，协程并没有停止运行，而是一直运行到计算结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i is 0</span><br><span class="line">[DefaultDispatcher-worker-1] i is 1</span><br><span class="line">[DefaultDispatcher-worker-1] i is 2</span><br><span class="line">[main] start</span><br><span class="line">[DefaultDispatcher-worker-1] i is 3</span><br><span class="line">[DefaultDispatcher-worker-1] i is 4</span><br><span class="line">[DefaultDispatcher-worker-1] finally is run</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>我们现在有两种方式可以让计算代码变的是可取消的。</p>
<ul>
<li>周期性的调用一个挂起函数，该挂起函数会检查取消状态。比如<code>yield()</code>，这里不演示了。</li>
<li>显示的检查其取消状态</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> nextTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive) &#123;</span><br><span class="line">                <span class="comment">// 会在CPU上空转很多次</span></span><br><span class="line">                <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">                <span class="keyword">if</span> (now &gt;= nextTime) &#123;</span><br><span class="line">                    log(<span class="string">&quot;i is <span class="subst">$&#123;i++&#125;</span>&quot;</span>)</span><br><span class="line">                    nextTime += <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">450</span>)</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>isActive</code>。它是协程的一个扩展属性。其定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true when the current Job is still active (has not completed and was not cancelled yet).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> CoroutineScope.isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = coroutineContext[Job]?.isActive ?: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>我们再次运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i is 0</span><br><span class="line">[DefaultDispatcher-worker-1] i is 1</span><br><span class="line">[DefaultDispatcher-worker-1] i is 2</span><br><span class="line">[main] start</span><br><span class="line">[DefaultDispatcher-worker-1] finally is run</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>现在我们已经可以完全的去取消一个协程，在实际开发中，我们会在<code>finally</code>块中去关闭一些网络连接，或者关闭文件IO等。这通常来说都不是什么问题，并且这些都不会涉及到挂起函数。但是在一些极端情况下，我们不得不去调用挂起函数，但是<code>finally</code>代码块本身就意味着，协程即将结束，只是做最后的收尾工作。我们先看示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">10</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is start&quot;</span>)</span><br><span class="line">            delay(<span class="number">200</span>)</span><br><span class="line">            log(<span class="string">&quot;finally is end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main] i am 0</span><br><span class="line">[main] i am 1</span><br><span class="line">[main] i am 2</span><br><span class="line">[main] finally is start</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>我们可以观察到<code>finally is end</code>并没有打印出来，这里可以思考一下为什么没有打印出来？如果思考不出来可以用<code>try-catch</code>去包裹<code>delay(200)</code>试试。</p>
<p>我直接说解决方案，可以将代码放置到<code>withContext(NonCancellable)&#123;&#125;</code>中去，在这种结构中，我们实际使用了<code>withContext()</code>函数和<code>NonCancellable</code>上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">10</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                log(<span class="string">&quot;finally is start&quot;</span>)</span><br><span class="line">                delay(<span class="number">200</span>)</span><br><span class="line">                log(<span class="string">&quot;finally is end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main] i am 0</span><br><span class="line">[main] i am 1</span><br><span class="line">[main] i am 2</span><br><span class="line">[main] finally is start</span><br><span class="line">[main] finally is end</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>这里的<code>withContext()</code>是一个挂起函数，它<strong>不会创建新的协程</strong>，只可能会导致线程的切换。它会在指定的协程上运行挂起代码块。并且挂起函数直至代码块运行结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * A non-cancelable job that is always [active][Job.isActive].</span><br><span class="line"> * It is designed for [withContext] function to prevent cancellation</span><br><span class="line"> * of code blocks that need to be executed without cancellation.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public object NonCancellable : AbstractCoroutineContextElement(Job), Job</span><br></pre></td></tr></table></figure>

<p>大体意思是：始终处于活动状态的不可取消<code>Job</code>。它是为<code>withContext</code>功能设计的，以防止取消需要执行而不取消的代码块。这就是一种固定写法，就不赘述了。</p>
<h4 id="协程超时"><a href="#协程超时" class="headerlink" title="协程超时"></a>协程超时</h4><p>　　协程提供了两个超时的挂起函数分别是<code>withTimeout()</code>和<code>withTimeoutOrNull()</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    withTimeout(<span class="number">1900</span>) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">400</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个输出结果应该是显而易见的。这两个函数都是可以有返回结果的。我们现在在函数里面添加一个返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeout&lt;String&gt;(<span class="number">1900</span>) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">400</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;result&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;result = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>削微的运行一下下就可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i am 0</span><br><span class="line">[DefaultDispatcher-worker-1] i am 1</span><br><span class="line">[DefaultDispatcher-worker-1] i am 2</span><br><span class="line">[DefaultDispatcher-worker-1] i am 3</span><br><span class="line">[DefaultDispatcher-worker-1] i am 4</span><br></pre></td></tr></table></figure>

<p>超时其实还是走的取消机制，输出的结果也比较好理解，如果还是不理解就用<code>try-catch</code>去包裹超时函数运行。<code>withTimeoutOrNull()</code>其实就是帮我们捕获了异常，然后在超时后返回一个<code>null</code>给我们。代码就不演示了。</p>
<h3 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h3><h4 id="挂起函数的组合"><a href="#挂起函数的组合" class="headerlink" title="挂起函数的组合"></a>挂起函数的组合</h4><p>　　前面我们说挂起函数只能在协程或者另一个挂起函数中被调用。我们现在可以来组合使用，先定义两个测试方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunA</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;suspend fun A start&quot;</span>)</span><br><span class="line">    delay(<span class="number">200</span>)</span><br><span class="line">    log(<span class="string">&quot;suspend fun A end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunB</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;suspend fun B start&quot;</span>)</span><br><span class="line">    delay(<span class="number">300</span>)</span><br><span class="line">    log(<span class="string">&quot;suspend fun B end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在需要知道两个方法的结果值的和。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> a = suspendFunA()</span><br><span class="line">        <span class="keyword">val</span> b = suspendFunB()</span><br><span class="line">        log(<span class="string">&quot;<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22:02:21.508 [DefaultDispatcher-worker-1] suspend fun A start</span><br><span class="line">22:02:21.714 [DefaultDispatcher-worker-2] suspend fun A end</span><br><span class="line">22:02:21.716 [DefaultDispatcher-worker-2] suspend fun B start</span><br><span class="line">22:02:22.020 [DefaultDispatcher-worker-2] suspend fun B end</span><br><span class="line">22:02:22.021 [DefaultDispatcher-worker-2] 200 + 300 &#x3D; 500</span><br><span class="line">22:02:22.025 [DefaultDispatcher-worker-2] time &#x3D; 513</span><br></pre></td></tr></table></figure>

<p>这里的A和B都是挂起函数，会直接挂起当前协程。这并没有实现我们想要的并发。这里我们就会使用到一个新的协程构建器<code>async</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Deferred&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>　　从概念上来说，<code>async</code>和<code>launch</code>一样，它会开启一个单独的协程，可以与协程并发工作。区别在于后者返回的是一个<code>Job</code>对象，但是<code>Job</code>不会持有任何的结果值。而前者返回的是一个<code>Deferred</code>对象，该对象是<code>Job</code>的一个子类对象，并且它额外实现了<code>await()</code>用于获取结果，需要注意的是<code>await()</code>是一个挂起函数。既然是<code>Job</code>的子类，那么<code>Job</code>有的功能，它也全都有。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> a = async &#123; suspendFunA() &#125;</span><br><span class="line">        <span class="keyword">val</span> b = async &#123; suspendFunB() &#125;</span><br><span class="line">        log(<span class="string">&quot;<span class="subst">$&#123;a.await()&#125;</span> + <span class="subst">$&#123;b.await()&#125;</span> = <span class="subst">$&#123;a.await() + b.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22:20:54.846 [DefaultDispatcher-worker-1] start</span><br><span class="line">22:20:54.847 [DefaultDispatcher-worker-2] suspend fun A start</span><br><span class="line">22:20:54.848 [DefaultDispatcher-worker-2] suspend fun B start</span><br><span class="line">22:20:55.049 [DefaultDispatcher-worker-1] suspend fun A end</span><br><span class="line">22:20:55.149 [DefaultDispatcher-worker-1] suspend fun B end</span><br><span class="line">22:20:55.150 [DefaultDispatcher-worker-1] 200 + 300 &#x3D; 500</span><br><span class="line">22:20:55.150 [DefaultDispatcher-worker-1] time &#x3D; 304</span><br></pre></td></tr></table></figure>

<p>千万不能写成下面这样，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> a = async &#123; suspendFunA() &#125;.await()</span><br><span class="line">        <span class="keyword">val</span> b = async &#123; suspendFunB() &#125;.await()</span><br><span class="line">        log(<span class="string">&quot;<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>b</code>需要依赖<code>a</code>的结果，我们不得不在<code>b</code>之前去等待结果。应该考虑使用<code>withContext()</code>来编写逻辑。</p>
<h4 id="父子协程"><a href="#父子协程" class="headerlink" title="父子协程"></a>父子协程</h4><p>　　当一个协程是通过另一个协程的协程作用域(<code>CoroutineScope</code>)来启动的，那么这个协程就会通过<code>CoroutineScope.coroutineContext</code>来继承其上下文信息，同时新的协程会成为外部协程的一个孩子，当父协程被取消时，该父协程会通过递归的方式一并取消子协程的执行。举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    <span class="keyword">val</span> jobParent = launch &#123;</span><br><span class="line">        log(<span class="string">&quot;run in parent&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> jobChild = launch &#123;</span><br><span class="line">            log(<span class="string">&quot;run in child&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            log(<span class="string">&quot;i am child&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;run in GlobalScope&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            log(<span class="string">&quot;I don&#x27;t have a father&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">300</span>)</span><br><span class="line">    log(<span class="string">&quot;jobParent is cancel&quot;</span>)</span><br><span class="line">    jobParent.cancelAndJoin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>jobChild</code>和<code>jobParent</code>就是父子关系，但是<code>job</code>和他们不存在父子关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-2] run in parent</span><br><span class="line">[DefaultDispatcher-worker-1] run in child</span><br><span class="line">[DefaultDispatcher-worker-3] run in GlobalScope</span><br><span class="line">[DefaultDispatcher-worker-3] jobParent is cancel</span><br><span class="line">[DefaultDispatcher-worker-2] I don&#39;t have a father</span><br></pre></td></tr></table></figure>

<h4 id="协程的完成"><a href="#协程的完成" class="headerlink" title="协程的完成"></a>协程的完成</h4><p>　　无论是使用的<code>launch</code>还是<code>runBlocking</code>它们都被称为协程构建器，它们有一个最重要的特点就是会先构建一个<code>CoroutineScope</code>的实例，并将它添加到代码块的作用域之内，而不用显示将它们<code>join()</code>在一起。这是因为<strong>外部协程会等待该作用域的所有启动的协程全部执行完毕后才会完成</strong>。我们先看一个代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的示例，用于对比</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job: Job = GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        job.join()</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main] launch</span><br><span class="line">[main] kotlin coroutine run</span><br></pre></td></tr></table></figure>

<p>我们对比两个示例，会发现我们没有调用<code>join()</code>函数，但是依然打印了kotlin coroutine run。我们修改一下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们思考一下，这段代码会打印什么？</p>
<p>如果你的分析结果和打印结果不一致，说明还是我没有讲清楚，可以按照示例重新在梳理一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main] launch</span><br></pre></td></tr></table></figure>

<h4 id="父子协程的异常和取消"><a href="#父子协程的异常和取消" class="headerlink" title="父子协程的异常和取消"></a>父子协程的异常和取消</h4><p>　　当子协程出现异常而没有处理时，错误就会向上传递给父协程，取消父协程。这个时候这个父协程的所有子协程都会被一并取消。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> value1 = async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="number">90000</span>)</span><br><span class="line">            <span class="number">100</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;value1 finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value2 = async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log(<span class="string">&quot;result = <span class="subst">$&#123;value1.await() + value2.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] start</span><br><span class="line">[DefaultDispatcher-worker-3] value1 finally is run</span><br><span class="line">E&#x2F;AndroidRuntime: FATAL EXCEPTION: DefaultDispatcher-worker-1</span><br><span class="line">    Process: space.lianxin.coroutine, PID: 12512</span><br><span class="line">    java.lang.RuntimeException</span><br></pre></td></tr></table></figure>

<p>在一些特定的情况下，我们需要子协程出现异常时，父协程不退出。我们可以使用<strong>监督</strong>的来解决。使用方式是将<code>SupervisorJob</code>在协程启动时当上下文元素传入。</p>
<h4 id="协程的调试"><a href="#协程的调试" class="headerlink" title="协程的调试"></a>协程的调试</h4><p>现在的IDE基本都能够做到和线程一样，在IDE中直接通过debug窗口调试，并且调试方式是差不多的。这种调试方式我就不讲解了，我们看如何通过日志进行调试。</p>
<ul>
<li><p>单元测试</p>
<p>通过添加Jvm参数进行调试。Ddit Configurations -&gt; VM options -&gt; 如下参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dkotlinx.coroutines.debug</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2023/03/12/xZuvq9KIS7BCUAd.png" alt="Coroutine_ide_debug" style="zoom:100%;" />
</li>
<li><p>App项目</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        System.setProperty(<span class="string">&quot;kotlinx.coroutines.debug&quot;</span>, <span class="string">&quot;on&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这个时候我们运行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;log in debug&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1 @coroutine#2] log in debug</span><br></pre></td></tr></table></figure>

<p>我们现在获取的线程名称就变成了<code>线程名称 @协程名称#协程ID</code>的格式。这些名字和ID都是可以进行修改的，后续会讲解到。</p>
<h3 id="协程的启动模式"><a href="#协程的启动模式" class="headerlink" title="协程的启动模式"></a>协程的启动模式</h3><p>　　观察协程构建器，无论是<code>launch</code>还是<code>async</code>除了协程闭包之外，还需要额外的两个参数，分别是<code>CoroutineContext</code>和<code>CoroutineStart</code>对象，这个<code>CoroutineStart</code>是一个枚举对象，我们先从简单的入手。</p>
<ul>
<li><p><code>DEFAULT</code></p>
<p>　　在我们调用协程构建器的时候默认传入的就是<code>DEFAULT</code>。当我们使用这个值作为协程的启动模式时，会根据当前的协程上下文<strong>立即开始调度执行</strong>。</p>
</li>
<li><p><code>LAZY</code></p>
<p>　　这个就见名知意了，我们在一些特定的情况下，其实并不希望协程被创建后就立即执行，而是在一个合适的时机开始执行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> a = async(start = CoroutineStart.LAZY) &#123; suspendFunA() &#125;</span><br><span class="line">        <span class="keyword">val</span> b = async(start = CoroutineStart.LAZY) &#123; suspendFunB() &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">        a.start()</span><br><span class="line">        b.start()</span><br><span class="line"></span><br><span class="line">        log(<span class="string">&quot;<span class="subst">$&#123;a.await()&#125;</span> + <span class="subst">$&#123;b.await()&#125;</span> = <span class="subst">$&#123;a.await() + b.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21:18:01.949 [DefaultDispatcher-worker-1] start</span><br><span class="line">21:18:02.258 [DefaultDispatcher-worker-2] suspend fun A start</span><br><span class="line">21:18:02.260 [DefaultDispatcher-worker-2] suspend fun B start</span><br><span class="line">21:18:02.463 [DefaultDispatcher-worker-3] suspend fun A end</span><br><span class="line">21:18:02.562 [DefaultDispatcher-worker-3] suspend fun B end</span><br><span class="line">21:18:02.564 [DefaultDispatcher-worker-1] 200 + 300 &#x3D; 500</span><br><span class="line">21:18:02.564 [DefaultDispatcher-worker-1] time &#x3D; 615</span><br></pre></td></tr></table></figure>

<p>当我们使用<code>LAZY</code>去创建一个协程的时候，协程并不会立即执行，而是等到我们调用<code>start()</code>或者<code>await()</code>方法之后才会开始执行，当然你也可以使用<code>join</code>方法。通过上面的示例也可以看出来，这里可以思考一下换成使用<code>a.await()</code>让协程开始执行会出现什么样的结果。</p>
</li>
<li><p><code>ATOMIC</code></p>
<p>　　到目前为止，这都只是一个试验性质的Api。它会根据协程的上下文原子地(即，以一种不可取消的方式)调度其执行。这类似于<code>DEFAULT</code>，但是协程在开始执行之前不能被取消。因为其还处在试验阶段，我也没有具体的去研究，就不介绍了。</p>
</li>
<li><p><code>UNDISPATCHED</code></p>
<p>　　它的作用是<strong>立即在父协程的上下文中执行代码</strong>，直到遇到第一个挂起函数。在第一个挂起函数之后，代码就会由当前协程的调度器调度执行。废话少说，直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    log(<span class="string">&quot;parent start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">        log(<span class="string">&quot;run in parent&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">&quot;run in child Dispatchers&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">&quot;run in child Dispatchers again&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;parent end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21:51:04.151 [DefaultDispatcher-worker-1] parent start</span><br><span class="line">21:51:04.152 [DefaultDispatcher-worker-1] run in parent</span><br><span class="line">21:51:04.152 [DefaultDispatcher-worker-1] parent end</span><br><span class="line">21:51:04.253 [main] run in child Dispatchers</span><br><span class="line">21:51:04.356 [main] run in child Dispatchers again</span><br></pre></td></tr></table></figure>

<p>观察输出，我们可以看到，被创建的协程是立即执行的，并且和父协程运行在同一个线程中。和我们所期待的结果是一致的。对于这段代码不管运行多少次，结果总是确定的。</p>
</li>
</ul>
<h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>　　协程总是会在某个协程上下文（<code>CoroutineContext</code>）中执行，协程上下文本质上是各种元素所构成的一个集合，主要的元素就包括协程的<code>Job</code>以及<code>CoroutineDispatcher</code>。我们可以先看看源码中的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Persistent context for the coroutine. It is an indexed set of [Element] instances.</span></span><br><span class="line"><span class="comment"> * An indexed set is a mix between a set and a map.</span></span><br><span class="line"><span class="comment"> * Every element in this set has a unique [Key].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E : Element</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　从定义来看，它拥有的<code>Element</code>是任意多个的，但是对于相同Key的元素只会有一个。前面我们说到的协程的分发器，其实就是协程上下文的一个子类。协程为我们内置了很多已经实现的协程上下文。</p>
<h4 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h4><p>　　这是一个我们使用非常频繁的协程上下文对象，他的继承自<code>AbstractCoroutineContextElement</code>。<code>AbstractCoroutineContextElement</code>是<code>Element</code>的一个子类对象。其实我们阅读源码的时候，会发现大部分的协程上下文都是<code>Element</code>的子类。只有少数如<code>EmptyCoroutineContext</code>和<del><code>TestCoroutineContext</code></del>才是直接继承自<code>CoroutineContext</code>的。</p>
<p>　　回到我们的协程分发器，<code>CoroutineDispatcher</code>他是一个抽象类并且实现了<code>ContinuationInterceptor</code>接口，所有的协程分发器，必须是它的一个子类。它的主要作用就是确定当前协程由那个线程或者线程池来执行。</p>
<h5 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h5><p>　　这是一个协程分发器内置对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        DefaultExecutor.shutdown()</span><br><span class="line">        DefaultScheduler.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们上面已经使用过很多次这个协程分发器了，我们看看具体的含义。</p>
<ul>
<li><p>Dispatcher.Default</p>
<p>首先说，它被用于<strong>计算密集型</strong>任务。它是由Jvm共享线程池支持。默认情况下最大的并级别为CPU的核心数，但是不会低于2。可以通过<code>limitedParallelism()</code>进行修改。如果从最外层的协程开始都没有指定任何的分发器和拦截器，那么所有标准协程构建器如<code>launch</code>就会使用它进行创建协程。</p>
</li>
<li><p>Dispatcher.Main</p>
<p>这个<strong>只能用于UI线程</strong>，并且需要使用引入对于的平台库才能使用。</p>
</li>
<li><p>Dispatcher.IO</p>
<p>它被用于<strong>IO密集型</strong>任务，也就是阻塞情况偏多的情况，如文件读写，网络请求等。它<code>Default</code>共享线程池，不过对IO进行了优化。</p>
</li>
<li><p>Dispatcher.Unconfined</p>
<p>前面三个都很好理解，使用也很多。这是一个非常特殊的分发器，它是<strong>不加任何限制的去执行</strong>我们的协程代码。我们所指定的代码到底是由哪一个线程或者线程池来执行是不确定的，需要根据程序实际执行的情况去确定。</p>
</li>
</ul>
<p>Dispatcher.Unconfined会在父协程的分发器上执行代码，但是仅仅持续到第一个挂起点。当挂起结束恢复执行时，会在挂起函数的线程执行后续代码直到再次遇到挂起函数。但如果之前的线程已经取消或者死亡，则会自己开启一个新的线程来执行。</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;active&quot;</span>)</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Main) &#123; log(<span class="string">&quot;do something in main&quot;</span>) &#125;</span><br><span class="line">        log(<span class="string">&quot;after main&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123; log(<span class="string">&quot;do something in IO&quot;</span>) &#125;</span><br><span class="line">        log(<span class="string">&quot;after IO&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Default) &#123; log(<span class="string">&quot;do something in Default&quot;</span>) &#125;</span><br><span class="line">        log(<span class="string">&quot;after Default&quot;</span>)</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们可以看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] active</span><br><span class="line">[DefaultDispatcher-worker-1] start</span><br><span class="line">[main] do something in main</span><br><span class="line">[main] after main</span><br><span class="line">[DefaultDispatcher-worker-1] do something in IO</span><br><span class="line">[DefaultDispatcher-worker-1] after IO</span><br><span class="line">[DefaultDispatcher-worker-3] do something in Default</span><br><span class="line">[DefaultDispatcher-worker-3] after Default</span><br><span class="line">[DefaultDispatcher-worker-3] finish</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>这是一个极少使用的协程分发器，在我们的实际开发过程中几乎不会使用到它。它避免调度程序中启动的嵌套协程形成事件循环以至堆栈溢出。</p>
<h5 id="asCoroutineDispatcher"><a href="#asCoroutineDispatcher" class="headerlink" title="asCoroutineDispatcher()"></a>asCoroutineDispatcher()</h5><p>　　除去默认提供的一些分发器，我们还可以自行实现协程的分发器，或者使用java线程池来分派协程任务。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Converts an instance of ExecutorService to an implementation of ExecutorCoroutineDispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ExecutorService.<span class="title">asCoroutineDispatcher</span><span class="params">()</span></span>: ExecutorCoroutineDispatcher =</span><br><span class="line">    ExecutorCoroutineDispatcherImpl(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出<code>asCoroutineDispatcher()</code>本身是一个扩展方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    <span class="keyword">val</span> singleThread = Executors.newSingleThreadExecutor()</span><br><span class="line">    launch(singleThread.asCoroutineDispatcher()) &#123;</span><br><span class="line">        log(<span class="string">&quot;i am run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，确实能得到预期的结果。不过这种写法多来点你就会发现你创建了非常多的线程池，并且每个任务还都在运行中。这是因为我们并没有关闭线程池。解决办法无外乎就是两种，第一种：声明成为全局线程池，提供给别处使用。第二种方式就是在协程最后一行去调用线程池的<code>shutdown()</code>方法。</p>
<h5 id="newSingleThreadContext"><a href="#newSingleThreadContext" class="headerlink" title="newSingleThreadContext"></a>newSingleThreadContext</h5><p>　　创建一个单线程的协程分发器。</p>
<h5 id="newFixedThreadPoolContext"><a href="#newFixedThreadPoolContext" class="headerlink" title="newFixedThreadPoolContext"></a>newFixedThreadPoolContext</h5><p>　　这个就是与<code>newSingleThreadContext()</code>对应的了。</p>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>先提出一个问题，我们如何通过正在执行的协程，获取当前协程的Job对象？协程Job是属于协程上下文的一部分，我们也说了协程上下文本身就是一个元素的集合。我们可以在协程的作用域获取到协程上下文，并且通过这个上下文获取到Job对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job: Job? = coroutineContext[Job]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>coroutineContext</code>是协程作用域的一个成员属性，我们可以拿到，<code>[]</code>是通过操作符重载get方法而来的。现在问题就在Job是怎么来的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [Job] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的协程上下文的定义也抄下来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E : Element</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里对于不怎么熟悉语法的人来说获取Job应该是<code>val job: Job? = coroutineContext[Job.Key]</code>才对啊？为什么<code>.Key</code>没有了。这里可能有点绕。仔细梳理一下还是比较容易理解的，问题就出在Job的伴生对象上。接口的伴生对象可以直接通过接口的名称获取，这是kotlin的一个语法糖。这个语法糖希望对你自己阅读源码有一定的帮助。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> job: Job? = coroutineContext[Job]</span><br><span class="line">        log(<span class="string">&quot;job = <span class="variable">$job</span>&quot;</span>)</span><br><span class="line">        job?.cancelAndJoin()</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-3] start</span><br><span class="line">[DefaultDispatcher-worker-3] job &#x3D; &quot;coroutine#3&quot;:StandaloneCoroutine&#123;Active&#125;@785e25f</span><br></pre></td></tr></table></figure>

<p>通过这个示例我们对协程上下文应该是更进一步的了解了。</p>
<h4 id="CoroutineName"><a href="#CoroutineName" class="headerlink" title="CoroutineName"></a>CoroutineName</h4><p>　　它也是一个协程上下文，就像线程可以被命名一样，<code>CoroutineName</code>用于给协程指定协程名称。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    launch(CoroutineName(<span class="string">&quot;myCoroutine&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-2 @myCoroutine#3] log</span><br></pre></td></tr></table></figure>

<h4 id="协程上下文的组合"><a href="#协程上下文的组合" class="headerlink" title="协程上下文的组合"></a>协程上下文的组合</h4><p>　　我们观察协程构建器，入参只要需要一个<code>CoroutineContext</code>对象，如果我们需要使用协程命名并且还要指定他的分发器应该怎么做？协程上下文重载了<code>+</code>操作符，我们可以通过<code>+</code>号来组合多个协程上下文。需要注意的是他是通过Key来覆盖的，也就是说同一类型的协程上下文只能有一个。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    launch(Dispatchers.Main + CoroutineName(<span class="string">&quot;myCoroutine1&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;log1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Main + CoroutineName(<span class="string">&quot;myCoroutine2&quot;</span>) + Dispatchers.IO) &#123;</span><br><span class="line">        log(<span class="string">&quot;log2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1 @coroutine#2] log</span><br><span class="line">[main @myCoroutine1#3] log1</span><br><span class="line">[DefaultDispatcher-worker-3 @myCoroutine2#4] log2</span><br></pre></td></tr></table></figure>

<h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>协程作用域(<code>CoroutineScope</code>)，用于管理协程：</p>
<ul>
<li><p>管理启动协程的方式</p>
<p>它定义了<code>launch</code>、<code>async</code>、<code>withContext</code>等协程启动方法，并在这些方法内定义了启动子协程时上下文的继承方式。</p>
</li>
<li><p>管理协程生命周期</p>
<p>它定义了<code>cancel()</code>方法，用于取消当前作用域，同时取消作用域内所有协程。</p>
</li>
</ul>
<p>我们应该如何区分协程上下文和协程作用域呢？从类定义看，他们非常类似，最终目的都是管理协程，但正如Kotlin协程负责人Roman Elizarov在Coroutine Context and Scope中所说，二者的区别只在于使用目的的不同：<strong>作用域用于管理协程；而上下文只是一个记录协程运行环境的集合</strong>。他们的关系如下：</p>
<img src="https://s2.loli.net/2023/03/12/tBAThZaYOHymqof.png" alt="Coroutine_relation" style="zoom:100%;" />

<h3 id="约定和经验"><a href="#约定和经验" class="headerlink" title="约定和经验"></a>约定和经验</h3><h4 id="避免使用GlobalScope-launch"><a href="#避免使用GlobalScope-launch" class="headerlink" title="避免使用GlobalScope.launch"></a>避免使用GlobalScope.launch</h4><p>　　GlobalScope是实现了CoroutineScope的单例对象，含有一个空的上下文对象。这意味着它的生命周期与整个应用绑定，并且永远不会被主动取消，这是危险的。正确的做法是将自己的组件实现CoroutineScope，并在组件销毁时调用作用域的cancel()方法。实现方式多使用委托。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">         cancel() <span class="comment">// cancel is extension on CoroutineScope</span></span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vertx例子</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineVerticle</span> : <span class="type">Verticle</span>, <span class="type">CoroutineScope &#123;</span></span></span><br><span class="line">  <span class="comment">// 默认上下文使用context.dispatcher()</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext <span class="keyword">by</span> lazy &#123; context.dispatcher() &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="suspend和CoroutineScope扩展"><a href="#suspend和CoroutineScope扩展" class="headerlink" title="suspend和CoroutineScope扩展"></a>suspend和CoroutineScope扩展</h4><p>　　在Kotlin中，有两个约定俗成的东西：</p>
<ul>
<li>每一个仅被声明为<code>suspend</code>的方法。会等待其内部的逻辑全部完成之后再返回给调用者。</li>
<li>每一个被声明为<code>CoroutineScope</code>扩展方法的方法，都会立即返回，但是并发的执行扩展方法的内容。</li>
</ul>
<p>这两个是约定俗成的，这也是为什么在源码中，<code>launch</code>和<code>async</code>是扩展方法，而<code>runBlocking</code>和<code>withContext</code>却是<code>suspend</code>方法。如果一个方法定义成下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">myfun</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>它是suspend方法，同时也是CoroutineScope的扩展方法，调用者并不知道在方法内是否会启动新的协程，凭空给代码增加了复杂度，因此不推荐使用。suspend方法就应该在所有任务都完成后再返回。如果在suspend方法内部有需要并发执行的内容，那就应该等待他们都完成后再返回，此时可以使用<code>coroutineScope&#123;&#125;</code>，而不是在方法签名上加上CoroutineScope扩展。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">myfun</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span> = coroutineScope &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样才更加符合惯用法。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　本文详述了Kotlin协程的基本用法及重要组件的运行机制，对它们有了足够详细的了解和清晰的认识有助于我们写出正确的Kotlin协程代码。当然实际使用还需要根据具体情况选择恰当的API。虽然讲了这么多，但是异步流和通道这些都还没介绍到。只有下次和底层逻辑一起讲了。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>异步</tag>
        <tag>结构化并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的委托</title>
    <url>/2023/02/08/Delegation/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　见名知意，委托就是把工作委托/委派给另一个对象去处理，对象本身不会去做这个工作。相较于Java，这是Kotlin中引入的新的语法：<strong>委托</strong>，通过<code>by</code>关键字来使用。在kotlin当中，委托主要分为两种，分别是<strong>属性委托</strong>和<strong>类委托</strong>。</p>
<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>　　属性也就是变量，在kotlin中声明一个变量的时候会为这个变量添加<code>get</code>和<code>set</code>方法。而属性委托就是将<code>get</code>和<code>set</code>委托给一个第三方实现。这个时候我们就可以按照语法格式：<code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code>来声明一个委托属性，因为kotlin语法的特性，这里的<code>&lt;类型&gt;</code>是可以省略的，由kotlin进行类型推定。举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> param: <span class="built_in">Int</span> <span class="keyword">by</span> Delegate()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(param.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为<code>val</code>只有<code>get</code>方法，所以我们只需要把<code>param</code>的<code>get</code>方法委托给<code>Delegation</code>类来处理。这个时候我们需要在<code>Delegation</code>中去实现被委托的方法。有两种方式来实现，第一种方式就是纯手写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** get委托 */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现委托的规则只有简简单单的几点要求。</p>
<ul>
<li>方法必须被<code>operator</code>修饰，这个关键字是操作符重载。</li>
<li>方法名必须是<code>getValue</code>。</li>
<li><code>thisRef</code>是类型可以是任意类型，这个参数的表示那些类可以使用<code>by Delegation()</code>实现委托。比如我这里将类型修改为<code>Activity</code>类型，那么我就只能在Activity及其子类中委托给Delegation，并且可以通过<code>thisRef</code>拿到委托对象的所有公开方法和属性。而在<code>ByTest</code>类中使用就会报找不到方法的错误，无法通过编译。</li>
<li><code>property</code>类型固定为<code>KProperty&lt;*&gt;</code></li>
<li>返回值为委托属性的类型。</li>
</ul>
<p>当然也可以通过第二种方式来实现，实现<code>ReadOnlyProperty</code>接口来减少我们自己手写出错的概率。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是Kotlin的ReadOnlyProperty接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> ReadOnlyProperty<span class="type">&lt;in T, out V&gt;</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of the property for the given object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thisRef the object for which the value is requested.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> property the metadata for the property.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the property value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们实现这个接口，并且重写getValue方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegation</span> : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">Any?, Int</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** get委托 */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这两种实现方法本质上是一样的，看个人喜好都可以。刚才我们说了<code>get</code>方法的委托，那么<code>set</code>方法呢？<code>set</code>实现和<code>get</code>基本一致。除此之外，我们还要明确的一个事就是属性委托必须实现的就是get，set是一个可选实现。这也对应了我们的val或者var属性。<code>set</code>方法实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mValue: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** get委托 */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** set委托 */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mValue = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也有对应的接口<code>ReadWriteProperty</code>可以实现，这里就不贴代码了。我们对比<code>get</code>方法，我们发现只是将返回值改到了入参的位置，其他并无要求。你可以按照上述的任意一种方式实现属性委托，这样在对属性进行取值/赋值操作的时候就会直接调用委托类的<code>getValue</code>和<code>setValue</code>方法，而且是<strong>每次都会调用</strong>。</p>
<p>　　我们知道，对于android来说，kotlin最后会转换成字节码给虚拟机调用。难道java也新增了这个语法？不对吧，我们看看底层是怎么去实现的。对<code>ByTest</code>的字节码进行反编译看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> KProperty[] $$delegatedProperties = <span class="keyword">new</span> KProperty[]&#123;(KProperty)Reflection.mutableProperty1(<span class="keyword">new</span> MutablePropertyReference1Impl(ByTest.class, &quot;param&quot;, &quot;getParam()I&quot;, <span class="number">0</span>))&#125;;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Delegation param$delegate = <span class="keyword">new</span> Delegation();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.param$delegate.getValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setParam</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.param$delegate.setValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">0</span>], var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String var1 = String.valueOf(<span class="keyword">this</span>.getParam());</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦哟，原来就是先创建一个委托类对象，然后取值/赋值就调用委托类对象的的<code>getValue</code>和<code>setValue</code>方法。就干了个简简单单的事嘛！还以为是什么了不得东西呢。</p>
<p>　　上面说的就是标标准准的属性委托，因为我们大多数的时候都是按照这样去实现。它的使用场景也很多，举个栗子：我们使用Intent在Activity中传递数据我们改用下面这种形式来简化取值操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委托类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntentExtraDelegation</span>&lt;<span class="type">T : Any</span>&gt;</span>(</span><br><span class="line">    <span class="comment">/** 获取intent中值的key */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> key: String,</span><br><span class="line">    <span class="comment">/** 默认值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> defaultValue: T</span><br><span class="line">) : ReadWriteProperty&lt;Activity, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isGetEnd = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Activity</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGetEnd) <span class="keyword">return</span> defaultValue</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        defaultValue = thisRef.intent.extras?.<span class="keyword">get</span>(key) <span class="keyword">as</span>? T ?: defaultValue</span><br><span class="line">        isGetEnd = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> defaultValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Activity</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        defaultValue = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Activity中使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XxxActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> value <span class="keyword">by</span> IntentExtraDelegation(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jerry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在获取intent传递的值的时候就简单很多。<code>by</code>关键字还可以在方法的内部使用，不过需要注意的是在方法内部使用时，<strong>委托的方法第一个入参是null，我们需要将第一个入参改为可空类型</strong>。相信看到这里，你已经掌握了属性委托。那么我们看看除此之外的另外几种标准委托。</p>
<h4 id="直接委托"><a href="#直接委托" class="headerlink" title="直接委托"></a>直接委托</h4><p>　　直接委托就是将一个属性的<code>get/set</code>方法直接委托给另一个属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldValue: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Int</span> <span class="keyword">by</span> ::oldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种委托，对value就行操作时会同时修改<code>oldValue</code>的值，因为从本质上来说就是调用了<code>oldValue</code>的<code>set</code>方法。看着好像确实没什么用，不过也有它的使用场景，比如说可见性封装：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _data: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt; <span class="keyword">by</span> ::_data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对外屏蔽了数据操作，提供只读访问。</p>
<h4 id="Delegates"><a href="#Delegates" class="headerlink" title="Delegates"></a>Delegates</h4><p>　　Kotlin提供了一个<code>Delegates</code>类，这个类可以提供一些委托的实现，比如观察属性变化，通过查看源码(源码也只有几十行，完全值得看一看)，也就是标准委托加回调实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;初始值&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;property = <span class="variable">$property</span> oldValue = <span class="variable">$oldValue</span> newValue = <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Delegates类还提供了<code>Delegates.notNull()</code>和<code>Delegates.vetoable()</code>方法，感兴趣可以自己查看用法。</p>
<h4 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h4><p>　　属性映射也算是kotlin的一个语法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span></span>(map: HashMap&lt;String, Any&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过key和属性名一致来映射</span></span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> value: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么可以这样呢？因为Map它也实现了<code>getValue</code>方法，想不到吧！</p>
<h4 id="by-lazy"><a href="#by-lazy" class="headerlink" title="by lazy"></a>by lazy</h4><p>　　首先需要明确的一点是，只有<code>by</code>才kotlin的关键字，<code>lazy</code>只是一个高阶函数。<code>by lazy</code>只能对<strong>被val修饰属性使用</strong>。lazy是将传入的初始化函数（即Lambda表达式）包装成为一个Lazy类，这个Lazy类就是一个委托对象(它实现了<code>getValue</code>方法)，直到第一次访问(使用)它，它才会去执行初始化的函数并记录和返回结果。很简单嘛，减少资源的占用。之后再次调用只返回之前记录的结果。也就是说初始化函数只会执行一次，并且是线程安全的。</p>
<p>　　应用场景也有很多，比如这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _context: Context? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> context: Context</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (_context == <span class="literal">null</span>) &#123;</span><br><span class="line">                _context = initContext()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _context!!</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改用by lazy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> context <span class="keyword">by</span> lazy &#123; initContext() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改用<code>by lazy</code>之后语义简洁明了，上上之选嘛。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>　　属性委托使用非常的广泛，你可以借助它实现数据和View绑定等。即使你完全不使用这些东西，仍然可以通过其他方式去实现完全一样的效果，但是你不能不会。不用和不会完全是两个概念。</p>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>　　那么类委托又是什么呢？三句话说完：</p>
<ol>
<li>委托只能对接口(方法)进行委托，不能对类。</li>
<li>类委托不局限于单一的接口。</li>
<li>如果被委托的类实现了接口的成员，则调用被委托的类重写成员时，调用的则是被委托的类重写的成员，而不会委托给委托类实现。</li>
</ol>
<p>　　我们观察上面介绍的属性委托，不难发现，属性委托不管是那种方式，都是通过委托<code>get/set</code>方法实现的。第一点对于属性委托也是一样的，也好理解。剩下的两句是什么意思呢？举个例子：我们现在要使用一个Map存储数据，并且能够得到最后一次放入的key和value。我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTestMap</span> : <span class="type">MutableMap</span>&lt;<span class="type">String, String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mMap = HashMap&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastKey: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastValue: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">String</span>)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastKey = key</span><br><span class="line">        <span class="keyword">this</span>.lastValue = value</span><br><span class="line">        <span class="keyword">return</span> mMap.put(key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>)</span></span> = mMap[key]</span><br><span class="line">    <span class="comment">// 其他未实现的方法也通过调用mMap对应的方法，实现了一堆方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLastKey</span><span class="params">()</span></span> = lastKey</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLastValue</span><span class="params">()</span></span> = lastValue</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = ByTestMap()</span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    map.getLastKey()</span><br><span class="line">    map.getLastValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在确实实现了这样的一个功能，但是我们重写了一大堆方法，可是我们真正有用的也只有<code>put</code>方法，那如果一个接口有几十上百个抽象方法我们不是直接麻掉？我们这个时候就可以用类委托来实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByTestMap</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> mMap: MutableMap&lt;String, String&gt;) : MutableMap&lt;String, String&gt; <span class="keyword">by</span> mMap &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastKey: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastValue: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">String</span>)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastKey = key</span><br><span class="line">        <span class="keyword">this</span>.lastValue = value</span><br><span class="line">        <span class="keyword">return</span> mMap.put(key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLastKey</span><span class="params">()</span></span> = lastKey</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLastValue</span><span class="params">()</span></span> = lastValue</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = ByTestMap(HashMap())</span><br><span class="line">    map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">    map.getLastKey()</span><br><span class="line">    map.getLastValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我们来说只需要重写put方法就能实现我们的需求，所以我们只用重写<code>put</code>就可以了。</p>
<p>　　按照这个代码来解释一下上面的概念。<strong>委托只能对接口进行委托，不能对类</strong>：这个很好理解，就是委托的始终都是方法。<strong>类委托不局限于单一的接口</strong>：这个很好理解吧！不多逼逼。<strong>如果被委托的类实现了接口的成员，则调用被委托的类重写成员时，调用的则是被委托的类重写的成员，而不会委托给委托类实现</strong>：现在我们的<code>ByTestMap</code>就是一个被委托的类，并且我们只重写了<code>put</code>方法,  当调用者调用<code>put</code>方法时的调用的是我们重写过后的<code>put</code>方法。当调用<code>get</code>/<code>containsKey</code>/<code>remove</code>等我们没有重写的方法，那么就会调用<code>mMap</code>的对应方法。</p>
<p>　　类委托简简单单嘛！实现原理呢就是编译成我们类委托一开始写得代码，emm…。</p>
<h4 id="多个类委托"><a href="#多个类委托" class="headerlink" title="多个类委托"></a>多个类委托</h4><p>　　如果理解了类委托，多个类委托不也是手拿把掐。我说一下语法格式就行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> a: A,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> b: B</span><br><span class="line">) : A <span class="keyword">by</span> a, B <span class="keyword">by</span> b &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>A</code>和<code>B</code>有一模一样的方法呢，就需要在<code>C</code>中自己去实现这个方法就OK了。类委托呢，就这点东西，也不难。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin协程-Flow与Channel篇</title>
    <url>/2023/03/19/Coroutine2/</url>
    <content><![CDATA[<p>　　是基于协程基础能力搭建的一套数据流框架，主要用于处理复杂的异步数据。对于一个Android开发者来说，处理异步数据我们有很多的选择，诸如LiveData和RxJava等等。但是为什么会选择使用Flow，且听我娓娓道来。</p>
<h3 id="序列Sequence"><a href="#序列Sequence" class="headerlink" title="序列Sequence"></a>序列Sequence</h3><p>　　在学习Flow之前，我们可以先看看在kotlin中一个和Flow类似的<code>Sequence</code>类。序列中的数据并非像集合一样一次性返回全部结果给调用端，而是计算完一个数据后就可以返回一个数据给调用端。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSequence</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123;</span><br><span class="line">    repeat(<span class="number">4</span>) &#123;</span><br><span class="line">        yield(it + <span class="number">1</span>)</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getSequence().forEach &#123;</span><br><span class="line">        log(<span class="string">&quot;111 it = <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    getSequence().forEach &#123;</span><br><span class="line">        log(<span class="string">&quot;222 it = <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14:32:11.869 [main] 111 it &#x3D; 1</span><br><span class="line">14:32:13.872 [main] 111 it &#x3D; 2</span><br><span class="line">14:32:15.874 [main] 111 it &#x3D; 3</span><br><span class="line">14:32:17.876 [main] 111 it &#x3D; 4</span><br><span class="line">14:32:19.879 [main] 222 it &#x3D; 1</span><br><span class="line">14:32:21.881 [main] 222 it &#x3D; 2</span><br><span class="line">14:32:23.883 [main] 222 it &#x3D; 3</span><br><span class="line">14:32:25.885 [main] 222 it &#x3D; 4</span><br></pre></td></tr></table></figure>

<p>观察日志输出时间，可以看到我们他是分次返回结果给调用端的，并且它阻塞了调用它的线程。但是实际上我们更多的可能是释放线程，让它去做别的事情。这就引出了Flow。</p>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>　　Flow有一个很大的优势，就是它的操作符跟集合操作符高度一致。只要会用List、Sequence，那么就可以快速上手 Flow 的操作符。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>　　Flow分为三个部分，分别是数据的发送方，中间处理层，接收方（也就是终止操作符）。先看一个小栗子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFlow</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    repeat(<span class="number">10</span>) &#123;</span><br><span class="line">        emit(it + <span class="number">1</span>)</span><br><span class="line">        log(<span class="string">&quot;emit it = <span class="subst">$&#123;it + <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    getFlow()</span><br><span class="line">    	.filter &#123; it &gt; <span class="number">1</span> &#125;</span><br><span class="line">    	.map &#123; it * <span class="number">2</span> &#125;</span><br><span class="line">    	.take(<span class="number">2</span>)</span><br><span class="line">    	.collect &#123;</span><br><span class="line">            log(<span class="string">&quot;it = <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码，可以看出Flow也是一种链式调用的方式，<code>flow&#123;&#125;</code>是一个高阶函数用于创建一个新的Flow。可以在其内部调用挂起函数<code>emit()</code>发送数据，属于发送方。<code>filter</code>和<code>map</code>属于中间处理层。<code>collect</code>是终止操作符，用于处理数据。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>异步</tag>
        <tag>结构化并发</tag>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title>EventBus使用并手撸核心源码</title>
    <url>/2021/06/20/EventBus/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>　　在Android系统中，相同组件或不同组件之间都在进行消息传递，对于用户直观感受来说就是App的不同界面在同步更新。在EventBus出现之前我们使用的通信方式有<code>Handler</code>、<code>BroadcastReceiver</code>、<code>接口回调</code>、<code>Binder</code>等方式。</p>
<p>　　但是在上面的通信方式中，各有各问题，<code>Handler</code>容易内存泄露。而<code>BroadcastReceiver</code>所消耗的资源又很大。出错不易定位等等。在这样的情况下诞生了<strong>EventBus</strong>。它的出现就是为了整合通信方式。</p>
<h3 id="EventBus优点及使用"><a href="#EventBus优点及使用" class="headerlink" title="EventBus优点及使用"></a>EventBus优点及使用</h3><p>　　EventBus是一种用于Android的发布/订阅事件总线。通过解耦发布者和订阅者来简化事件传递。使用的是<strong>发布/订阅模式</strong>，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。从作者的Github上偷一张图就是这样的：</p>
<img src="https://i.loli.net/2021/06/20/gpadQZ2bu7CNADL.png" alt="EventBus发布/订阅模式" style="zoom: 80%;" />

<h4 id="EventBus优点"><a href="#EventBus优点" class="headerlink" title="EventBus优点"></a>EventBus优点</h4><ul>
<li><p>解耦</p>
<p><strong>简化了组件之间的通信，将事件的发布者和订阅者完全分离开来，避免了复杂且容易出错的依赖关系</strong>。假设现在某个App的用户，从个人主页进入了编辑资料页面并且修改了昵称，现在App个人主页和首页需要同步更新。代码实现的方式各种各样，如果有天产品经理抽风直接干掉了个人主页，这个时候如果存在依赖关系，直接GG。如果是使用的EventBus这种没有依赖关系的方式，代码中直接干掉个人主页就完全oj8k了。</p>
</li>
<li><p>简单</p>
<p>代码上使用呢是非常简单的，后面会介绍到。</p>
</li>
<li><p>很小很快</p>
<p>小呢指的是jar包体积小，不到60K（减少包体积必备）。快呢指的是响应快。</p>
</li>
<li><p>线程切换容易</p>
<p>除了线程切换容易还具有交付线程（delivery threads）、订阅者优先级等功能。delivery threads四种线程模型：</p>
<ul>
<li><p>POSTING(默认)：表示事件处理函数的线程跟发布事件的线程在同一个线程。</p>
</li>
<li><p>MAIN：表示事件处理函数的线程在主线程(UI)线程。</p>
</li>
<li><p>BACKGROUND：表示事件处理函数的线程在后台线程。</p>
</li>
<li><p>ASYNC：表示无论事件发布的线程是哪一个，始终会新建一个子线程运行。</p>
</li>
</ul>
<p>订阅者优先级就见名知意了。</p>
</li>
</ul>
<h4 id="EventBus使用"><a href="#EventBus使用" class="headerlink" title="EventBus使用"></a>EventBus使用</h4><p>　　第一步嘛，当然还是在模块的 build.gradle 构建脚本中添加EventBus依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.greenrobot:eventbus:3.2.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>导入完依赖之后，在需要接受EventBus事件的类中在合适的时机注册/注销EventBus。比如在Activity中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart()</span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop()</span><br><span class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然也可以选择在onCreate()和onDestroy()中</span></span><br></pre></td></tr></table></figure>

<p>　　当这些都准备完成之后，只需要<strong>发送事件</strong>和<strong>处理事件</strong>就完全OK了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送事件</span></span><br><span class="line">EventBus.getDefault().post(<span class="string">&quot;我是发送的字符串&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理事件</span></span><br><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN, priority = 1, sticky = false)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subscribeMethod</span><span class="params">(str: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    textView.text = str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　那么问题来了，我发送多种消息，订阅的消息也是多处订阅，他们之间是怎么匹配的呢？匹配的方式是通过<code>post</code>方法发送的值和被<code>@Subscribe</code>注解的方法的入参（入参有且仅有一个）一致性匹配。同时呢，我们也注意到<code>@Subscribe</code>有三个值可取，<code>threadMode</code>对应的交付线程(delivery threads)的四种模式，不记得可以看看上面。<code>priority</code>指定的是优先级，数值越大优先级就越高，就越先被处理，优先级有了是不是可以<strong>通过优先级+取消事件分发构建拦截链</strong>呢？。取消事件向下分发，<code>EventBus.getDefault().cancelEventDelivery(i)</code>这里的<code>i</code>指的是处理事件方法的入参名。最后一个<code>sticky</code>是用于处理<strong>粘性事件</strong>。</p>
<p>　　接着我们就来讲讲什么是<strong>粘性事件</strong>，在一般情况下EvnetBus发送了一条事件消息，如果没有对该事件感兴趣的订阅者，那么这条消息就消失了。粘性事件允许EvnetBus发送了事件消息之后，订阅者才注册到事件中心，依然能够收到该事件。对应代码也很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送粘性事件，EventData是随意创建的一个实体类。</span></span><br><span class="line">EventBus.getDefault().postSticky(EventData(<span class="number">1</span>, <span class="string">&quot;12&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理粘性事件(sticky = true)</span></span><br><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subscribeMethod</span><span class="params">(<span class="keyword">data</span>: <span class="type">EventData</span>)</span></span> &#123;</span><br><span class="line">    textView2.text = <span class="keyword">data</span>.toString()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后赠送一个 获取粘性事件和移除粘性事件的方法。</span></span><br><span class="line"><span class="keyword">val</span> event = EventBus.getDefault().getStickyEvent(EventData::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="keyword">if</span> (event != <span class="literal">null</span>) &#123;</span><br><span class="line">    EventBus.getDefault().removeStickyEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　粘性事件的应用场景非常多，比如我们现在监听了网络变化状态，根据网络状态多个页面的UI需要调整，有的UI甚至没有打开。这个时候粘性事件是不是就很好用了呢？</p>
<h4 id="EventBus3-新特性-–订阅者索引"><a href="#EventBus3-新特性-–订阅者索引" class="headerlink" title="EventBus3 新特性 –订阅者索引"></a>EventBus3 新特性 –订阅者索引</h4><p>　　默认情况下，EventBus在查找订阅者方法时采用的是反射（这也是为什么订阅方法无论是public还是private都能被找到的原因。）。订阅者索引是EventBus3的一个新特性。它可以加速订阅者的注册，是一个可选的优化。订阅者索引的原理是：使用EventBus的注解处理器在应用构建期间创建订阅者索引类，该类包含了订阅者和订阅者方法的相关信息。EventBus官方推荐在Android中使用订阅者索引以获得最佳的性能。</p>
<p>　　订阅者索引有一个前提就是<strong>必须</strong>是<code>@Subscribe</code>注解的方法才能被编入索引，同时Subscriber类和事件类必须是public。如果以上条件有不满足的地方，sorry啊，反射真的可以为所欲为.jpg（指用反射实现。）</p>
<p>如何生成索引? 下面这样↓↓</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> eventbus_version = <span class="string">&#x27;3.2.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&quot;org.greenrobot:eventbus:$eventbus_version&quot;</span></span><br><span class="line">    kapt <span class="string">&quot;org.greenrobot:eventbus-annotation-processor:$eventbus_version&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        <span class="comment">// 记住这个全类名</span></span><br><span class="line">        arg(<span class="string">&#x27;eventBusIndex&#x27;</span>, <span class="string">&#x27;space.lianxin.eventbus.EventBusIndex&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用索引？下面这样↓↓（官方原话）</p>
<blockquote>
<p><a href="https://greenrobot.org/eventbus/documentation/subscriber-index/">Subscriber Index</a></p>
</blockquote>
<p>　　<strong>至少构建一次项目</strong>以生成使用eventBusIndex指定的索引类。也就是我们先去编译一次项目，<strong>不要自己去写那个全类名的实体类</strong>。</p>
<p>然后你就可以看到一个这样的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(SecondActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">&quot;subscribeMethod&quot;</span>, space.lianxin.EventData.class, ThreadMode.MAIN, <span class="number">0</span>, <span class="keyword">true</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(MainActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">&quot;subscribeMethod&quot;</span>, String.class, ThreadMode.MAIN, <span class="number">1</span>, <span class="keyword">false</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这个类存放的两个索引刚好就是我在SecondActivity的<strong>粘性事件订阅</strong>和MainActivity的<strong>普通事件订阅</strong>。也不需要具体的了解。只要知道自动生成，大概放得是啥就OK了。</p>
<p>　　现在我们需要将这个自动生成的类加到EventBus中来使用，使得整个项目运行速度提升。我们上面使用的一直是<code>EventBus.getDefault()</code>，EventBus也可以通过build模式来构建，创建时通过<code>addIndex(instance)</code>来添加索引。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventBus.builder().addIndex(EventBusIndex()).build()</span><br></pre></td></tr></table></figure>

<p>　　如果我们只需要一个EventBus实例，也可以在Application中使用EventBusBuilder.installDefaultEventBus()将带有索引的 EventBus 设置为EventBus.getDefault()返回的实例就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Application中像这样</span></span><br><span class="line">EventBus.builder().addIndex(EventBusIndex()).installDefaultEventBus()</span><br><span class="line"><span class="comment">// 需要使用的地方获取到的eventBus就是建立索引的上面这个。</span></span><br><span class="line"><span class="keyword">val</span> eventBus = EventBus.getDefault()</span><br></pre></td></tr></table></figure>

<p>　　OK，EventBus的使用到目前为止就结束了，接着我们就来手撸一下核心源码。</p>
<h3 id="EventBus的实现思路"><a href="#EventBus的实现思路" class="headerlink" title="EventBus的实现思路"></a>EventBus的实现思路</h3><p>　　我们要想实现这样的一个通信框架，我们首先就应该去设计它的框架结构，这个呢，我们上面也有图解，我把它拿下来：</p>
<img src="https://i.loli.net/2021/06/20/gpadQZ2bu7CNADL.png" alt="EventBus框架" style="zoom: 80%;" />

<p>　　这样的框架结构是比较简单的（EventBus内部使用的设计模式有很多，例如单例、外观模式、观察者模式等，我只是简化它并且手撸核心源码），由Publisher发送一个Event事件到EventBus，再由EventBus将事件找到对应的订阅者，去响应onEvent事件。这个是一个非常典型的观察者模式。我们这里的EventBus起到的一个作用就是一个中间环节作用。既然EventBus需要将接受到的Event事件去找到对应的订阅者，就一定需要一张表，这张表呢就是一个订阅者表。EventBus同时呢也需要被Publisher和Subscriber拿到，为了简化我就设计成单例。</p>
<p>　　现在我们只用把消息发送的逻辑和接受事件处理（建立订阅者表）逻辑编写就OK了。</p>
<h3 id="监听者注册的实现"><a href="#监听者注册的实现" class="headerlink" title="监听者注册的实现"></a>监听者注册的实现</h3><p>　　根据上面的理解我们大致可以得到这样的一个中心类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LianXinEventBus</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信息表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> cacheMap: HashMap&lt;Any, List&lt;SubscribeMethod&gt;&gt; = HashMap()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mHandler: Handler = Handler(Looper.getMainLooper())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> instance: LianXinEventBus? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDefault</span><span class="params">()</span></span>: LianXinEventBus &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 双重校验锁</span></span><br><span class="line">                synchronized(LianXinEventBus::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        instance = LianXinEventBus()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">post</span><span class="params">(msgType: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来完善监听者注册，也就是<code>register</code>方法的实现。但是我们发现在LianXinEventBus中我们不知道监听者的信息，不确定他监听了什么。而我们又必须要获取到这些信息，这时我们就可以通过一个很重要的机制——<strong>反射机制</strong>来实现我们的需求。</p>
<p>　　简单讲一下反射知识点，反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的<strong>属性</strong>和<strong>方法</strong>。正常来说，我们调用类的方法或者字段都是通过<code>object.method()</code>等形式来调用，而反射差不多也是同理的，但是我们需要获取的对象变成了<code>Class</code>类对象。个人理解是对象可以抽象成一个类，而类可以抽象成一个<code>Class</code>类。这样我们通过获取到的<strong>Class类对象</strong>就可以获取到这个类的所有信息，有点绕口，但是不难理解。</p>
<p>　　通过这个机制我们就拿到了注册对象的所有方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 获取监听者的订阅方法列表 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSubscribeMethodList</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: List&lt;SubscribeMethod&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> list = ArrayList&lt;SubscribeMethod&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取class类对象，等同获取了所有信息</span></span><br><span class="line">    <span class="keyword">val</span> clz = obj.javaClass</span><br><span class="line">    <span class="comment">// 因为不知道有哪些方法，我们全部获取。</span></span><br><span class="line">    <span class="comment">// 获取所有的方法列表，包括私有方法，但不包括超类的方法。</span></span><br><span class="line">    <span class="keyword">val</span> methods = clz.declaredMethods</span><br><span class="line">    <span class="comment">// 获取所有的公开方法列表。</span></span><br><span class="line">    <span class="comment">// 包括由类或接口声明的方法以及从超类和超接口继承的方法。</span></span><br><span class="line">    <span class="comment">// 最后选了上面这种，不能因为是私有方法就不管了。</span></span><br><span class="line">    <span class="comment">// val methods = clz.methods</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　可以看到我们已经拿到了所有的方法列表，接着我们需要做的就是循环遍历判断那个方法是订阅的监听者方法。这里我们可以有许多种思路，比如我们的监听者方法固定以什么开头，这种方式很不自由，而且容易出错（EventBus最开始就是这样的方式），比较一般的做法了就是<strong>注解</strong>。</p>
<p>　　注解有什么用？一般用来注释说明和传值。那我们就可以定义一个自己的注解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">LianXinSubscribe</span></span>(</span><br><span class="line">    <span class="keyword">val</span> threadModel: ThreadModel</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadModel</span> </span>&#123;</span><br><span class="line">        Posting,</span><br><span class="line">        Main,</span><br><span class="line">        Async</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在我们就可以通过注解找到我们要找到方法了，现在我们需要把找到的方法保存下来，也就是保存到我们定义的<code>SubscribeMethod</code>类中。要保存这个方法，一个方法最重要的是入参和返回值没有问题吧？但是我们用不到返回值，所以我们只关心入参，我们只需要保存入参信息就oj8k了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeMethod</span></span>(</span><br><span class="line">    <span class="keyword">val</span> method: Method,</span><br><span class="line">    <span class="keyword">val</span> paraType: Class&lt;*&gt;,</span><br><span class="line">    <span class="keyword">val</span> threadModel: LianXinSubscribe.ThreadModel</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">methods.forEach &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">annotation</span> = it.getAnnotation(LianXinSubscribe::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">annotation</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> paras = it.parameterTypes</span><br><span class="line">        <span class="keyword">if</span> (paras.size != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;订阅方法的入参只能是一个&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(SubscribeMethod(it, paras[<span class="number">0</span>], <span class="keyword">annotation</span>.threadModel))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后的register方法就完善了。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先判断是否已经注册了，没注册才去注册</span></span><br><span class="line">    <span class="keyword">var</span> list = cacheMap[obj]</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = getSubscribeMethodList(obj)</span><br><span class="line">        <span class="keyword">if</span> (!list.isNullOrEmpty()) &#123;</span><br><span class="line">            cacheMap[obj] = list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们注意到<code>clz.declaredMethods</code>获取的方法是当前对象的方法不包含超类方法。那么如果在超类有监听者方法我们就不管了么？我们还要通过<code>clz.superclass</code>获取超类再来一遍。超类还有超类。这里我就不做优化了。</p>
<h3 id="事件发送的实现"><a href="#事件发送的实现" class="headerlink" title="事件发送的实现"></a>事件发送的实现</h3><p>　　现在我们已经完成了监听注册的实现，我们发送了一个事件通过这个表格我们就可以找到对应监听实现了吧，感觉不难，直接开撸。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">post</span><span class="params">(msgType: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = cacheMap.keys.iterator()</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 循环每个监听者</span></span><br><span class="line">        <span class="keyword">val</span> obj = iterator.next()</span><br><span class="line">        <span class="keyword">val</span> subscribeMethods = cacheMap[obj]</span><br><span class="line">        subscribeMethods?.forEach &#123;</span><br><span class="line">            <span class="comment">// 判断监听者方法</span></span><br><span class="line">            <span class="keyword">if</span> (it.paraType.isAssignableFrom(msgType::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line">                <span class="comment">// 切换一下线程</span></span><br><span class="line">                <span class="keyword">when</span> (it.threadModel) &#123;</span><br><span class="line">                    LianXinSubscribe.ThreadModel.POSTING -&gt; &#123;</span><br><span class="line">                        invoke(it, obj, msgType)</span><br><span class="line">                    &#125;</span><br><span class="line">                    LianXinSubscribe.ThreadModel.Main -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">                            invoke(it, obj, msgType)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mHandler.post &#123;</span><br><span class="line">                                invoke(it, obj, msgType)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LianXinSubscribe.ThreadModel.Async -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 这里和并发编程挂钩，可以使用线程池等等。这里偷懒了。</span></span><br><span class="line">                        thread &#123;</span><br><span class="line">                            invoke(it, obj, msgType)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 发送通知 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(subscribeMethods: <span class="type">SubscribeMethod</span>, obj: <span class="type">Any</span>, msgType: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> method = subscribeMethods.method</span><br><span class="line">    <span class="comment">// private需要处理</span></span><br><span class="line">    method.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method.invoke(obj, msgType)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e1: ReflectiveOperationException) &#123;</span><br><span class="line">        e1.printStackTrace()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e2: IllegalArgumentException) &#123;</span><br><span class="line">        e2.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件发送逻辑也处理完了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="meta">@LianXinSubscribe(LianXinSubscribe.ThreadModel.Main)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subscribeMethod</span><span class="params">(str: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">	textView.text = str</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送事件</span></span><br><span class="line">LianXinEventBus.getDefault().post(<span class="string">&quot;我是发送的字符串&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="最后展示一下完整代码"><a href="#最后展示一下完整代码" class="headerlink" title="最后展示一下完整代码"></a>最后展示一下完整代码</h3><p>　　码字不易啊，且码且珍惜。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> space.lianxin.lianxinbus</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Handler</span><br><span class="line"><span class="keyword">import</span> android.os.Looper</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ===========================================</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lianxin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/6/17 18:44</span></span><br><span class="line"><span class="comment"> * ===========================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LianXinEventBus</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信息表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> cacheMap: HashMap&lt;Any, List&lt;SubscribeMethod&gt;&gt; = HashMap()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mHandler: Handler = Handler(Looper.getMainLooper())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> instance: LianXinEventBus? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDefault</span><span class="params">()</span></span>: LianXinEventBus &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 双重校验锁</span></span><br><span class="line">                synchronized(LianXinEventBus::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        instance = LianXinEventBus()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 先判断是否已经注册了，没注册才去注册</span></span><br><span class="line">        <span class="keyword">var</span> list = cacheMap[obj]</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">            list = getSubscribeMethodList(obj)</span><br><span class="line">            <span class="keyword">if</span> (!list.isNullOrEmpty()) &#123;</span><br><span class="line">                cacheMap[obj] = list</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取监听者的订阅方法列表 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSubscribeMethodList</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: List&lt;SubscribeMethod&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;SubscribeMethod&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取class类对象，等同获取了所有信息</span></span><br><span class="line">        <span class="keyword">val</span> clz = obj.javaClass</span><br><span class="line">        <span class="comment">// 因为不知道有哪些方法，我们全部获取。</span></span><br><span class="line">        <span class="comment">// 获取所有的方法列表，包括私有方法，但不包括超类的方法。</span></span><br><span class="line">        <span class="keyword">val</span> methods = clz.declaredMethods</span><br><span class="line">        <span class="comment">// 获取所有的公开方法列表。</span></span><br><span class="line">        <span class="comment">// 包括由类或接口声明的方法以及从超类和超接口继承的方法。</span></span><br><span class="line">        <span class="comment">// 最后选了上面这种，不能因为是私有方法就不管了。</span></span><br><span class="line">        <span class="comment">// val methods = clz.methods</span></span><br><span class="line">        methods.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">annotation</span> = it.getAnnotation(LianXinSubscribe::<span class="keyword">class</span>.java)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">annotation</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> paras = it.parameterTypes</span><br><span class="line">                <span class="keyword">if</span> (paras.size != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;订阅方法的入参只能是一个&quot;</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(SubscribeMethod(it, paras[<span class="number">0</span>], <span class="keyword">annotation</span>.threadModel))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">post</span><span class="params">(msgType: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> iterator = cacheMap.keys.iterator()</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 循环每个监听者</span></span><br><span class="line">            <span class="keyword">val</span> obj = iterator.next()</span><br><span class="line">            <span class="keyword">val</span> subscribeMethods = cacheMap[obj]</span><br><span class="line">            subscribeMethods?.forEach &#123;</span><br><span class="line">                <span class="comment">// 判断监听者方法</span></span><br><span class="line">                <span class="keyword">if</span> (it.paraType.isAssignableFrom(msgType::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line">                    <span class="comment">// 切换一下线程</span></span><br><span class="line">                    <span class="keyword">when</span> (it.threadModel) &#123;</span><br><span class="line">                        LianXinSubscribe.ThreadModel.POSTING -&gt; &#123;</span><br><span class="line">                            invoke(it, obj, msgType)</span><br><span class="line">                        &#125;</span><br><span class="line">                        LianXinSubscribe.ThreadModel.Main -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">                                invoke(it, obj, msgType)</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mHandler.post &#123;</span><br><span class="line">                                    invoke(it, obj, msgType)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        LianXinSubscribe.ThreadModel.Async -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 这里和并发编程挂钩，可以使用线程池等等。这里偷懒了。</span></span><br><span class="line">                            thread &#123;</span><br><span class="line">                                invoke(it, obj, msgType)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 发送通知 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(subscribeMethods: <span class="type">SubscribeMethod</span>, obj: <span class="type">Any</span>, msgType: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> method = subscribeMethods.method</span><br><span class="line">        <span class="comment">// private需要处理</span></span><br><span class="line">        method.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(obj, msgType)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e1: ReflectiveOperationException) &#123;</span><br><span class="line">            e1.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e2: IllegalArgumentException) &#123;</span><br><span class="line">            e2.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">unRegister</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> list = cacheMap[obj]</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            cacheMap.remove(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　整个流程下来是不是觉得开发一个这样的框架也不是很难，你上你也行的赶脚。这里面简化了很多东西，能够优化的内容也不少。希望各位看官不要止步于此，可以更好地深入的研究一哈。</p>
<h3 id="最最最最后说两句"><a href="#最最最最后说两句" class="headerlink" title="最最最最后说两句"></a>最最最最后说两句</h3><p>　　EventBus说了那么多好处，其实缺点也不少，如果你在项目中大量的使用它，你就需要创建多个常量或者实体类来维护管理它，这管理起来可太痛苦了。如果你能接收这个缺点，没问题，它还有个最大的缺点，发现了么？生命周期问题，很烦。怎么解决？<strong>LiveDataBus</strong>。但这已经不再我们今天的讨论范围了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>消息</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：final关键字</title>
    <url>/2020/09/30/Java%20final/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　final是Java中的一个关键字，可以修饰类、方法、成员变量和局部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 修饰内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123; <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125; &#125;</span><br><span class="line"><span class="comment">// 修饰方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 修饰成员变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> filed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 修饰方法参数（局部变量）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> String filed)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你<strong>永远不会</strong>让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>　　final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。也就是说子类是不能够存在和父类一模一样的方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String filed)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extendFinalClass</span> <span class="keyword">extends</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 因为父类为private方法，子类无法继承到，所以这是子类全新的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 可以重载父类的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 报错：override method is final</span></span><br><span class="line"><span class="comment">//	public final void method2(String filed) &#123;&#125;</span></span><br><span class="line">	<span class="comment">// 报错：override method is final</span></span><br><span class="line"><span class="comment">//	public void method2(String filed) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后补充一句就是所有的private方法都会被隐式指定为final。</p>
<p>　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求的值是<strong>地址的值</strong>不发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> filed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 引用不可变</span></span><br><span class="line">		<span class="keyword">final</span> FinalClass2 fc = <span class="keyword">new</span> FinalClass2();</span><br><span class="line">		System.out.println(fc.filed); <span class="comment">// 输出0</span></span><br><span class="line">		fc.filed = <span class="number">1</span>;</span><br><span class="line">		System.out.println(fc.filed); <span class="comment">// 输出1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="为什么要使用final"><a href="#为什么要使用final" class="headerlink" title="为什么要使用final?"></a>为什么要使用final?</h4><p>　　我们利用final加以修饰，无外乎两个原因，一个是设计原因，一个是效率原因，这是由于在不同的环境下final 有着不同的语义，所以可能会带来它的一些误解与误用。</p>
<ul>
<li><p><strong>设计原因</strong></p>
<p>　　从设计的角度来考虑为final类，此时final 的语义表明为：<strong>这个类不想在关系结构上做出任何的改变，也不希望有任何人可以继承自这个类，除此之外，就没有更多的限制了。</strong>例如：JDK中提供的基本数据包装类和String类就是final类。以上是我们从类的设计角度来考虑类被final 修饰的情况。此时，我们还需要注意一点，一个类被final之后，它就禁止了继承关系，那么一个这个类中的所有方法都是final修饰的，因为他们不会再被重写了。</p>
</li>
<li><p><strong>效率原因</strong></p>
<p>　　在我们说明final如何在效率上起到作用的时候，我们首先需要掌握一个知识点，即<strong>方法的内联</strong>。我们在掌握了这个知识点之后，可能对于对于final 修饰方法也就一并掌握了。我们要说明final为一个类（Class）带来效率上的好处，还真的得研究到蛮深入的地步，这个深入的地步可以到JVM对于方法的调用处理，也可以深入到寄存器如何存储指令，在这里我们就一切从简的说。</p>
</li>
</ul>
<p>　　一个类被final修饰后，它的方法默认被修饰为final ，这时方法的内联起到作用了。对于Java语言的编译器来说，我们无需刻意地利用内联做什么，编译器会自动地进行函数内联优化。什么是方法的内联呢？一句话直白的说就是把函数调用的方法直接内嵌到方法内部，减少函数调用的次数。实际就是（copy + replace）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = car.getPrice();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    z = car.getPrice();</span><br><span class="line">    discount = y - z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联之后的代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = car.price;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    z = car.price;</span><br><span class="line">    discount = y - z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种很典型的空间换时间的策略。</p>
<h4 id="final修饰域（Field）"><a href="#final修饰域（Field）" class="headerlink" title="final修饰域（Field）"></a>final修饰域（Field）</h4><p>​        final修饰域无外乎两种，一种是基本数据类型的数据域，一种是引用类型。首先是基本数据类型，这个是最常见的使用方法了。用法很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORDER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fee = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​        我认为final修饰基本数据类型的时候是最能体现final语义的一个用法。 出于以下两点考虑的时候，我们就要用final来修饰一个基本数据类型。</p>
<ol>
<li><p>程序编译期间的常量，它永远不会变。</p>
</li>
<li><p>在运行期间为一个final修饰的域初始化一个值，不希望它会发生变化。</p>
</li>
</ol>
<p>这两点对应代码块中的第一条和第二条。在这里补充一点堆、栈和常量池的相关知识。</p>
<img src="https://i.loli.net/2020/09/20/eYKk91aBnxVJzFi.png" alt="堆栈图" style="zoom: 90%;" />

<p>​        一个被final修饰的域就会被放在常量池中，这么做的原因就是为了提高效率。常量值装在需要计算的过程中，让它们充当类似于宏的身份，换句话说，编译器可以在编译期间提前完成一些计算工作，省去了在运行时对于变量的相对复杂的操作。对于static和没有static修饰的基本数据类型来说，是有差异的，差异就在于static修饰的域是在类载入的时候进行初始化的，所有实例共享同一个常量，同时Java虚拟机没有把它当作类变量，在使用它的任何类的常量池或者字节码流中直接存放的是它表示的常量值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块展示初始化过程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static final 只能在这里初始化或直接赋值</span></span><br><span class="line">  <span class="keyword">static</span> &#123; a = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="comment">// 动态代码块初始化</span></span><br><span class="line">  &#123; b = <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="comment">// 构造函数初始化</span></span><br><span class="line">  DateTest()&#123; c = <span class="number">3</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        对于引用类型来说，如果有final修饰一个引用类型变量，不是说明这个引用类型指向的实际地址的对象不可变，而是说这个引用不能再指向其他地址的对象，而对象本身是可以改变的。前面也说差不多，这确实有点迷惑。不过问题也不大，就说明一个变量的引用不能变而已，被固定了。对于这点，我就不做过多的解释了。</p>
<h4 id="final修饰方法参数"><a href="#final修饰方法参数" class="headerlink" title="final修饰方法参数"></a>final修饰方法参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalField</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalFieldClass ffc = <span class="keyword">new</span> FinalField().getObject(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    System.out.println(ffc.getStr());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FinalFieldClass <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalFieldClass() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// variable &#x27;str&#x27; is accessed from within inner class, needs to be declare final</span></span><br><span class="line">        <span class="comment">// 变量&#x27;str&#x27;是从内部类内部访问的，需要声明为final</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalFieldClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        final修饰方法参数，这里使用内部类来举例。我们跟着main函数执行顺序走，首先创建了一个<code>FinalField</code>对象，调用这个对象的<code>getObject()</code>方法，获取一个对象返回。假设现在这个<code>getObject()</code>方法没有加<code>final</code>关键字。首先将<code>str</code>压栈，创建了一个<code>FinalFieldClass</code>子类对象并返回。此时<code>getObject()</code>方法结束了，返回一个<code>ffc</code>对象，相应的局部变量就应该弹栈，也就是说<code>str</code>出栈了，栈中没有了<code>str</code>。那么问题来了，我现在去调用用<code>ffc</code>对象去调用<code>getStr()</code>方法。就获取不到对应的值了。但是JVM不会这么做，他会在弹出<code>str</code>的时候，就会拷贝一份<code>str</code>的值，当我们创建<code>FinalFieldClass</code>对象时将这个值存放在名为<code>str</code>的变量中，编译器必须检测对局部变量的访问，为每一个变量建立对应的数据域，并将局部变量拷贝到构造器中。</p>
<p>​        那么我们将方法参数列表中的变量修饰为final的，防止了这个变量<strong>在方法中被修改</strong>，因此就做到了局部变量与在内部类建立的拷贝副本保持了一致。而且在java8中已经可以不显示的使用final修饰。会被默认的指定为final。</p>
<h3 id="final在多线程"><a href="#final在多线程" class="headerlink" title="final在多线程"></a>final在多线程</h3><p>​        上面讲述的内容都是属于java的基础层面。后面我们看看在多线程中的final，final会进行怎么样的重排序，是否会导致线程安全问题。</p>
<h4 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h4><p>　　重排序是编译器或者CPU的代码的结构重排序，达到最佳效果。举个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">int</span> a1 = x * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = y * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = y * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排序之后的代码</span></span><br><span class="line"><span class="keyword">int</span> a1 = x * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = y * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = y * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>CPU只读一次的x和y值。不需反复读取寄存器来交替x和y值。</p>
<p>　　在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两初次读一个包含final域对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<h5 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">// 普通域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">// final域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>; <span class="comment">// 1.写普通域</span></span><br><span class="line">    b = <span class="number">2</span>; <span class="comment">// 2.写final域</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">    <span class="keyword">int</span> a = demo.a;    <span class="comment">// 4.读普通域</span></span><br><span class="line">    <span class="keyword">int</span> b = demo.b;    <span class="comment">// 5.读final域</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设线程A在执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法。</p>
<p>　　在写一个final域的时候，JMM会禁止将写final的代码重排序到构造函数之外。通过在写final域之后和构造函数完成之前添加一个storestore内存屏障来实现。当线程A调用调用<code>writer()</code>方法时，首先创建一个<code>FinalDemo</code>对象，并将这个对象的引用赋值给<code>finalDemo</code>。如果现在线程B没有重排序，可能执行的时序图如下：</p>
<img src="https://i.loli.net/2020/09/20/t5SVqZvUldzFke4.png" alt="可能时序" style="zoom:80%;" />



<p>​        由于a,b之间没有数据依赖性，普通域（普通变量）a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值（零值），这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。在读一个final域的时候，根据前面的规则，就是3一定会发生在5之前。</p>
<h5 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">  <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">    arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">      <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        针对引用数据类型，final域写针对编译器和处理器重排序<strong>增加</strong>了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</p>
<p>​        线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论。</p>
<img src="https://i.loli.net/2020/09/20/VFJ3A1Uu9cYMODx.png" alt="可能时序" style="zoom: 67%;" />

<p>​        由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>基本数据类型:</strong><br>        final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。<br>        final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</p>
<p><strong>引用数据类型：</strong><br>        额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序</p>
<p>​        final类型的变量可以保证在多线程发布某个对象时，这个对象的final域变量能够被正常的初始化（在写final变量后加了storestore屏障，在读final变量前加了loadload屏障），而普通类型的变量可能不会被正确的初始化，这样导致该对象在多个线程之间出现不一致的情况，这也就是我们所说的引用溢出。罪魁祸首是处理器重排序，因为处理器重排序不会影响单线程语义，但会破坏多线程语义，导致发布对象处在一个不一致的状态。</p>
<h3 id="Java-final-对比-kotlin-val"><a href="#Java-final-对比-kotlin-val" class="headerlink" title="Java final 对比 kotlin val"></a>Java final 对比 kotlin val</h3><p>​        在声明变量时，final同val一样只能一次赋值。但是在属性声明时却存在一定的差异</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">17</span></span><br><span class="line">    <span class="comment">// 通过get调用isAdult的结果是可变的。</span></span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是final就做不到</span></span><br><span class="line"><span class="comment">// 然而final声明的变量只要在构造方法之前去实例化就行。但是val声明就必须指定</span></span><br></pre></td></tr></table></figure>

<p>​        在方法中的参数，kotlin默认使用的就是val修饰。而在java中必须显示指定final才能达到相同效果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 报错：val cannot be reassigned</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过编译</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 报错Cannot assign a value to final variable &#x27;s&#x27;</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>　　从开头到结束一直在强调final修饰不可变。就比如不可变类String类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">// 实际存值得数组</span></span><br></pre></td></tr></table></figure>

<p>我们依然可以通过反射的方式去修改String的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s = <span class="string">&quot;modify me!!!!!&quot;</span>;</span><br><span class="line">    modifyStr(s);</span><br><span class="line">    System.out.println(s);<span class="comment">//输出 modify success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyStr</span><span class="params">(String s)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取String类中的value字段</span></span><br><span class="line">    Field field = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.在用反射时访问私有变量，需设置为true</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3.接收该String对象存的value值</span></span><br><span class="line">    <span class="keyword">char</span> value[]= (<span class="keyword">char</span>[]) field.get(s);</span><br><span class="line">    <span class="comment">// 4.通过数组索引赋值修改</span></span><br><span class="line">    String modify = <span class="string">&quot;modify success&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：这儿只能在数组原始对象长度范围内操作，不能新建对象扩容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        value[i] = modify.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是反射不是用来处理这些问题，而是为了拿到某些<code>private</code>字段或者私有方法而修改成自己想要的样式。同样的反射拿到的可能是一个final类型的数据。就可以像上述一样去修改。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin标准库函数let，apply，with，run，also</title>
    <url>/2020/11/02/Kotlin%20Basic%20Function/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>　　相比较于Java，在Kotlin中提供了许多的内置函数来帮助开发者写出更优雅的代码，同样的逻辑，在Kotlin中可以有更好的表达，当然你也可以不使用这些函数。</p>
<p>　　要弄明白这几个函数的具体使用，我们只需要从三个角度：是不是扩展函数？、返回值是什么？、this指的是谁？。只要弄清楚了这三点就理解了let,apply等函数。代码使用了lambda表达式，如果不清楚lambda表达式和扩展函数的可以参考下面的链接。</p>
<blockquote>
<p><a href="https://kaixue.io/kotlin-lambda/">Kotlin 的 Lambda 表达式，大多数人学得连皮毛都不算</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.kotlincn.net/docs/reference/extensions.html">Kotlin中文官方文档-扩展函数</a></p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>　　我们一开始就说了这些函数是为了让代码看起来更加的简洁，所以这些函数没有实现任何功能，即使不会也不会影响编码。但是别人用了你看不懂这就不好吧。</p>
<p>　　在学习使用过程中我们带着上述的三个问题。因为这几个函数有很多相似性，所以我重点介绍<code>let</code>函数和<code>apply</code>函数。当我们能够清晰的使用者两个函数时，其他函数也就不在话下。</p>
<h4 id="let的使用"><a href="#let的使用" class="headerlink" title="let的使用"></a>let的使用</h4><p>　　<code>let()</code>的定义是这样的，默认当前这个对象作为闭包(代码块)的it参数，返回值是函数里面最后一行。知道定义后看看let函数是去替换怎样的一种写法呢。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> activityMainTopTitle = findViewById&lt;TextView&gt;(R.id.activityMainTopTitle)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line">activityMainTopTitle.text = <span class="string">&quot;title&quot;</span></span><br><span class="line"><span class="comment">// ...更多的一些设置</span></span><br><span class="line">activityMainTopTitle.setBackgroundColor(Color.RED)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用let的写法</span></span><br><span class="line">activityMainTopTitle.let &#123;</span><br><span class="line">    it.text = <span class="string">&quot;title&quot;</span></span><br><span class="line">    <span class="comment">// ...更多的一些设置</span></span><br><span class="line">    it.setBackgroundColor(Color.RED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我个人一般不会这样去使用let，这样反而让代码变得不那么简洁（个人感觉，但是可读性变高了，可读性变高了不也是一种简洁么?）。多数情况下使用<code>?.let</code>的形式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList2: MutableList&lt;<span class="built_in">Int</span>&gt;? = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="keyword">if</span> (mutableList2 != <span class="literal">null</span>) &#123;</span><br><span class="line">    mutableList2.add(<span class="number">1</span>)</span><br><span class="line">    mutableList2.add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用let的写法。</span></span><br><span class="line"><span class="comment">// 表示mutableList2不为null的条件下，才会去执行let函数体</span></span><br><span class="line">mutableList2?.let &#123;</span><br><span class="line">    it.add(<span class="number">1</span>)</span><br><span class="line">    it.add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啊这，那我要是要处理为空的情况呢，是不是就不能使用let了？ 有得，有得。如果要实现<code>if-else</code>结构，你可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mutableList2?.let &#123;</span><br><span class="line">    it.add(<span class="number">1</span>)</span><br><span class="line">    it.add(<span class="number">2</span>)</span><br><span class="line">&#125; ?: let &#123;</span><br><span class="line">    <span class="comment">// mutableList2为空又怎么撸。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的一点就是<code>?.let</code>只能去实现<code>if-else</code>中非空判断的逻辑，其他情况还是做不到呢。最后我们看一下let函数的声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let函数声明（去掉契约contract部分，对实际实现无影响，方便理解。下同）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的代码和函数声明是不是对let的认识又清晰了很多呢，为了更好的回答上面的三个问题。我截取了Android Studio中的代码帮助大家理解：</p>
<p><img src="https://i.loli.net/2020/11/02/lzmDuJfXRKG8w6r.png" alt="KotlinNormal_let_1"></p>
<p>　　总结一下：let函数是一个扩展函数，其返回值是代码块最后一行。若最后一行没有返回值则返回值为<code>Unit</code>。在代码块中的this指代的是当前类对象。</p>
<h4 id="apply的使用"><a href="#apply的使用" class="headerlink" title="apply的使用"></a>apply的使用</h4><p>　　看完了let，现在来看看apply函数的使用：apply函数可以在函数内调用该对象的任意方法，并返回该对象，依然先看看常规写法和等价写法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line">mutableList.add(<span class="number">1</span>)</span><br><span class="line">mutableList.add(<span class="number">2</span>)</span><br><span class="line">mutableList.remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用apply写法</span></span><br><span class="line">mutableList.apply &#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let函数是it作为参数传进来，apply怎么变成了this，而且直接调用了<code>add()</code>方法？别急，先看看在Android Studio中是什么样的。</p>
<p><img src="https://i.loli.net/2020/11/02/8BindhsRYIDPqlE.png" alt="KotlinNormal_apply_1"></p>
<p>对比let函数，可以发现apply传入的参数名由<code>it</code>变成了<code>this</code>(但是他们指代的对象都是<code>mutableList</code>)，并且在函数内部this指代的对象也从<strong>类对象</strong>变成了<strong>当前对象</strong>。首先，我们知道<code>this</code>是具有特殊意义的。其次，我们也知道通过<code>this.method()</code>方式调用方法是可以省略<code>this</code>的，所以这也就是apply函数定义中的<strong>可以在函数内调用该对象的任意方法</strong>（私有方法还是不行哦）。最后来看一下apply函数和let函数的声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply函数的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啊？，这<code>T.()</code>是个什么啊？我们只见过<code>block: (T) -&gt; Unit</code>和<code>block: () -&gt; Unit</code>。也没有见过<code>block: T.() -&gt; Unit</code>啊！T不一个类么？怎么可以直接<code>T.()</code>呢？</p>
<p>　　我们看看文档的描述：</p>
<blockquote>
<p>　　这个函数接受一个名为<code>init</code>的参数，该参数本身就是一个函数。该函数的类型就是<code>T.() -&gt; Unit</code>这意味着我们需要向函数传递一个T类型的实例，并且我们可以在函数内部调用该实例的成员。并且可以通过this关键字访问。</p>
</blockquote>
<p>如果不懂也没有关系，我们只要记住<code>T.() -&gt; Unit</code>这是一个类型，并且函数体内部使用this关键字访问。这就是造成let和apply函数中传入的参数一个是it，一个是this的原因。我们就不详细讲解这个了。感兴趣的可以自行谷歌。</p>
<p>　　总结一下：apply函数是一个扩展函数。从截图中<code>returnResult</code>的类型也可以很明显看出来：其返回值就是当前对象。在代码块中的this指代的是调用apply函数的实例对象。</p>
<h4 id="with的使用"><a href="#with的使用" class="headerlink" title="with的使用"></a>with的使用</h4><p>　　从使用上来看with函数更像是let + apply函数。但是因为with函数是唯一的一个非扩展函数。所以在写法上和其他函数还是有一点差异。我们还是先看看实际的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList: MutableList&lt;<span class="built_in">Int</span>&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line">mutableList.add(<span class="number">1</span>)</span><br><span class="line">mutableList.add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> returnResult = <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用with写法</span></span><br><span class="line"><span class="keyword">val</span> returnResult = with(mutableList) &#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">    <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道函数都有<code>object?.method()</code>的形式去调用，表示object不为null时才去调用方法。with怎么去实现<code>?.</code>的调用形式。可以参考如下形式，这是我个人写的比较多的一种形式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList2: MutableList&lt;<span class="built_in">Int</span>&gt;? = mutableListOf()</span><br><span class="line">with(mutableList2 ?: <span class="keyword">return</span>) &#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是：这行with语句应该放在最后，即<strong>在with之后不会有代码需要执行</strong>。因为当<code>mutableList2</code>为null时会执行return结束整个方法的执行。如果后面还有代码需要执行的话还是老老实实的做非空判断吧。</p>
<p>　　总结一下：with = let + apply。with是唯一的一个非扩展函数。返回值和let一样是代码块最后一行。this指代的对象和apply一样是当前对象。</p>
<h4 id="run的使用"><a href="#run的使用" class="headerlink" title="run的使用"></a>run的使用</h4><p>　　run函数的定义和apply函数的定义很像，区别在于apply函数的返回值是当前对象，而run函数返回值是代码块最后一行。</p>
<h4 id="also的使用"><a href="#also的使用" class="headerlink" title="also的使用"></a>also的使用</h4><p>　　also函数的定义和let函数定义很像，区别在于let函数的返回值是代码块最后一行，而also的返回值是当前对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　没了？没了。真的没了！其实只要理解清楚了let函数和apply函数，基本就全部都清楚了。从其函数声明上就可以看出他们有许多相似之处。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apply函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// with函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// run函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// also函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给张表格清晰的对比它们之间的区别：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">是否为扩展函数</th>
<th align="center">返回值</th>
<th align="center">this指代的对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">let</td>
<td align="center">true</td>
<td align="center">代码块最后一行</td>
<td align="center">当前类对象</td>
</tr>
<tr>
<td align="center">apply</td>
<td align="center">true</td>
<td align="center">当前对象</td>
<td align="center">调用apply的对象</td>
</tr>
<tr>
<td align="center">with</td>
<td align="center">false</td>
<td align="center">代码块最后一行</td>
<td align="center">传入with的对象</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">true</td>
<td align="center">代码块最后一行</td>
<td align="center">调用run的对象</td>
</tr>
<tr>
<td align="center">also</td>
<td align="center">true</td>
<td align="center">当前对象</td>
<td align="center">当前类对象</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的操作符和部分关键字</title>
    <url>/2021/01/05/KotlinOperator/</url>
    <content><![CDATA[<h3 id="操作符-运算符-重载"><a href="#操作符-运算符-重载" class="headerlink" title="操作符(运算符)重载"></a>操作符(运算符)重载</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>操作符重载就是对预定义操作符赋予他们新的含义。重载的修饰符是operator</p>
</blockquote>
<p>　　什么是预定义操作符呢？举个例子，<code>+</code>号就是预定义操作符，对应的函数名就是<code>plus</code>。他的预先含义就是两个数值相加或者两个字符串相加返回一个新的值。我们可以使用<code>operator</code>操作符去实现自己的想要的功能。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>　　我们先看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">M</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> M.<span class="title">plus</span><span class="params">(other: <span class="type">M</span>)</span></span>: M &#123;</span><br><span class="line">    <span class="keyword">return</span> M(a + other.a, b + other.b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用处代码</span></span><br><span class="line"><span class="keyword">val</span> newM = M(<span class="number">1</span>, <span class="number">2</span>) + M(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>对于类M，我们重载了<code>+</code>号操作符，并且实现自己想要的内容。当然other的类型也可以是其他类型。这两个的类型不一定要一致，甚至你可以连返回值不一致。从某种意义上来讲这就是扩展函数。只不过你可以使用预定义的符号来代替你的函数名。</p>
<p>　　我们重载操作符主要是为了开发方便。例如你可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">plus</span><span class="params">(other: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> toMutableList().apply &#123; addAll(other) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处代码</span></span><br><span class="line"><span class="keyword">val</span> list1: List&lt;M&gt; <span class="comment">// 某个处理得到的值</span></span><br><span class="line"><span class="keyword">val</span> list2: List&lt;M&gt; <span class="comment">// 某个处理得到的值</span></span><br><span class="line"><span class="keyword">val</span> newList = list1 + list2</span><br></pre></td></tr></table></figure>

<p>同样的你还可以去实现其他的操作符。</p>
<h4 id="常用的操作符和对应函数名"><a href="#常用的操作符和对应函数名" class="headerlink" title="常用的操作符和对应函数名"></a>常用的操作符和对应函数名</h4><table>
<thead>
<tr>
<th align="center"><strong>表达式</strong></th>
<th align="center"><strong>函数名</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
<tr>
<td align="center">a++</td>
<td align="center">a.inc()</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()</td>
</tr>
<tr>
<td align="center">a + b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a - b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a * b</td>
<td align="center">a.times(b)</td>
</tr>
<tr>
<td align="center">a / b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a % b</td>
<td align="center">a.rem(b)，<del>a.mod(b)</del></td>
</tr>
<tr>
<td align="center">a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
<tr>
<td align="center">a in b</td>
<td align="center">b.contains(a)</td>
</tr>
<tr>
<td align="center">a += b</td>
<td align="center">a.plusAssign(b)</td>
</tr>
<tr>
<td align="center">a -= b</td>
<td align="center">a.minusAssign(b)</td>
</tr>
<tr>
<td align="center">a *= b</td>
<td align="center">a.timesAssign(b)</td>
</tr>
<tr>
<td align="center">a /= b</td>
<td align="center">a.divAssign(b)</td>
</tr>
<tr>
<td align="center">a %= b</td>
<td align="center">a.remAssign(b)，<del>a.modAssign(b)</del></td>
</tr>
</tbody></table>
<p>　　操作符还有一些我就不写了，需要值得注意的是<code>in</code>的操作符重载返回值必须是<code>Boolean</code>类型。对于如<code>+=</code>增量赋值等操作符返回值必须是<code>Unit</code>。如果记不清楚也没有关系，当你打出<code>operator</code>关键字的时候IDE会有提示。</p>
<p>最后附上官网地址</p>
<blockquote>
<p><a href="https://kotlinlang.org/docs/reference/operator-overloading.html">操作符重载 Operator overloading</a></p>
</blockquote>
<h3 id="部分关键字"><a href="#部分关键字" class="headerlink" title="部分关键字"></a>部分关键字</h3><h4 id="infix函数-中缀方法"><a href="#infix函数-中缀方法" class="headerlink" title="infix函数(中缀方法)"></a>infix函数(中缀方法)</h4><p>中缀方法其实和我们上面讲到的操作符重载有点像，不过与操作符重载不同的是，infix是我们自己定义的函数名称，然后像操作符一样的去使用他。</p>
<p>　　<code>infix</code>函数构成条件：</p>
<ul>
<li>参数列表只能有一个参数</li>
<li>必须是成员方法或者是扩展方法</li>
<li>使用<code>infix</code>修饰</li>
</ul>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个中缀函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">add</span><span class="params">(other: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + other</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 像二元操作符一样的去使用它</span></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = <span class="number">1</span> add <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这其实算是自定义操作符了吧（O(∩_∩)O哈哈~）不过也不算哈。因为要满足变量的命名规则。</p>
<h4 id="tailrec尾递归优化"><a href="#tailrec尾递归优化" class="headerlink" title="tailrec尾递归优化"></a>tailrec尾递归优化</h4><p>首先要理解的就是什么是尾递归：return除了调用自身，没有其余的操作我们把它称之为尾递归。<code>tailrec</code>是提醒编译器这是一个尾递归函数。在编译的时候可以将压栈弹栈转化为循环操作避免内存溢出。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>使用maven-publish发布aar包到maven仓库</title>
    <url>/2023/02/01/Maven/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　在日常开发过程中，为了避免重复造轮子或者是代码重复拷贝，我们都会将一部分代码打包成lib并且发布到maven仓库。发布到maven仓库有两种方式：分别是使用<strong>maven</strong>插件和<strong>maven-publish</strong>插件。这其中maven插件已经废弃了，就只梳理maven-publish插件的发布流程。</p>
<p>　　在这之前我们需要大致了解一下什么是<strong>Pom</strong>。<strong>POM</strong>（Project Object Model）指项目对象模型，用于描述项目构件的基本信息。一个有效的 POM 节点中主要包含以下信息：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
<th align="left">举例（以com.squareup.okhttp3:okhttp:4.10.0为例）</th>
</tr>
</thead>
<tbody><tr>
<td>groupId</td>
<td>组织 / 公司的名称</td>
<td align="left">com.squareup.okhttp3</td>
</tr>
<tr>
<td>artifactId</td>
<td>组件的名称</td>
<td align="left">okhttp</td>
</tr>
<tr>
<td>version</td>
<td>组件的版本</td>
<td align="left">4.11.0</td>
</tr>
<tr>
<td>packaging</td>
<td>打包的格式</td>
<td align="left">aar/jar</td>
</tr>
</tbody></table>
<p>Pom是一个xml文件，是Maven的核心。现在也不用关心那么多，只要知道重要包含的信息有哪些就OK。</p>
<h3 id="插件引入"><a href="#插件引入" class="headerlink" title="插件引入"></a>插件引入</h3><p>　　需要在对应module的gradle文件中引入插件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   id <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;maven-publish&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后就可以开始写发布的代码</p>
<h3 id="发布代码"><a href="#发布代码" class="headerlink" title="发布代码"></a>发布代码</h3><h4 id="最基本的本地发布"><a href="#最基本的本地发布" class="headerlink" title="最基本的本地发布"></a>最基本的本地发布</h4><p>我们先创建一个最基本的发布代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishing &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置maven仓库</span></span><br><span class="line">    repositories &#123; RepositoryHandler handler -&gt;</span><br><span class="line">        <span class="comment">// 发布到默认的本地maven仓库</span></span><br><span class="line">        <span class="comment">// 路径：C:\Users\userName\.m2\repository\</span></span><br><span class="line">        handler.mavenLocal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置发布产物</span></span><br><span class="line">    publications &#123; PublicationContainer publication -&gt;</span><br><span class="line">        <span class="comment">// 任务名称：maven(可以任意定义)</span></span><br><span class="line">        maven(MavenPublication) &#123; <span class="comment">// 容器可配置的信息 MavenPublication</span></span><br><span class="line">            <span class="comment">// 依赖 bundleReleaseAar 任务，并上传其产出的aar</span></span><br><span class="line">            <span class="comment">// 方式一：生成aar包</span></span><br><span class="line">            afterEvaluate &#123; artifact(tasks.getByName(<span class="string">&quot;bundleReleaseAar&quot;</span>)) &#125;</span><br><span class="line">            <span class="comment">// 方式二：指定生成的aar路径</span></span><br><span class="line">            <span class="comment">// artifact &quot;$buildDir/outputs/aar/$&#123;project.name&#125;-release.aar&quot;</span></span><br><span class="line">            <span class="comment">// 两种方式任选其一就可以了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// pom相关信息</span></span><br><span class="line">            groupId = <span class="string">&quot;com.xjk.basic&quot;</span></span><br><span class="line">            artifactId = <span class="string">&quot;basic&quot;</span></span><br><span class="line">            version = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写好之后就可以点击android studio的Gradle找到task列表找到对应模块的task任务：clean -&gt; build -&gt; publish</p>
<img src="https://s2.loli.net/2023/02/01/9PRkcB52brnMFAu.jpg" alt="task列表" style="zoom:100%;" />

<p>这样我们就发布好了一个本地仓库。我们可以在本地仓库的路径中找到它，它大致结构如下：</p>
<img src="https://s2.loli.net/2023/02/01/H3nvfMEVLrhUqtl.jpg" alt="publish_loacal_repo" style="zoom:100%;" />

<p>别的项目使用这个工程需要在现在工程的<code>build.gradle</code>（gradle7.0以上为<code>settings.gradle</code>）中添加：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 使用默认的本地仓库</span></span><br><span class="line">    mavenLocal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要使用依赖的模块配置中添加：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	.....</span><br><span class="line">    implementation <span class="string">&#x27;com.xjk.basic:basic:1.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样一个完整的发布流程和引用流程就结束了，但是呢！按照这个方式发布出来的代码被依赖时不能查看源码，引入的三方依赖也不能进行传递。</p>
<h4 id="上传源码"><a href="#上传源码" class="headerlink" title="上传源码"></a>上传源码</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.增加上传源码的task</span></span><br><span class="line">task sourceJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    archiveClassifier = <span class="string">&quot;sources&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.上传源码</span></span><br><span class="line">publishing &#123;</span><br><span class="line">    .....</span><br><span class="line">    publications &#123; PublicationContainer publicationContainer -&gt;</span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            artifact sourceJar <span class="comment">// 增加上传源码的task</span></span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在配置上传源码的任务时，这种配置如果库工程使用的是 Java 写的话，源码可以正常上传，但如果是 Kotlin 编写的库，发布 aar 包时，无法查看源码。原因是：通过android.sourceSets.main.java.srcDirs指定的源码，只能识别到 Java 文件，而 kt 文件被忽略了，from函数是可以指定源码路径的，所以可以利用这点直接把from函数的参数替换为源码路径来解决问题，即：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task sourceJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    <span class="comment">// 源码路径</span></span><br><span class="line">    from android.sourceSets.main.java.getSrcDirs()</span><br><span class="line">    archiveClassifier = <span class="string">&quot;sources&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">maven(MavenPublication) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// pom文件中声明依赖，从而传递到使用方</span></span><br><span class="line">    pom.withXml &#123;</span><br><span class="line">        <span class="keyword">def</span> dependenciesNode = asNode().appendNode(<span class="string">&#x27;dependencies&#x27;</span>)</span><br><span class="line">        configurations.implementation.allDependencies.each &#123;</span><br><span class="line">            <span class="comment">// 避免出现空节点或artifactId=unspecified的节点</span></span><br><span class="line">            <span class="keyword">if</span> (it.group != <span class="literal">null</span> &amp;&amp; (it.name != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;unspecified&quot;</span> != it.name) &amp;&amp; it.version != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">def</span> dependencyNode = dependenciesNode.appendNode(<span class="string">&#x27;dependency&#x27;</span>)</span><br><span class="line">                dependencyNode.appendNode(<span class="string">&#x27;groupId&#x27;</span>, it.group)</span><br><span class="line">                dependencyNode.appendNode(<span class="string">&#x27;artifactId&#x27;</span>, it.name)</span><br><span class="line">                dependencyNode.appendNode(<span class="string">&#x27;version&#x27;</span>, it.version)</span><br><span class="line">                dependencyNode.appendNode(<span class="string">&#x27;scope&#x27;</span>, <span class="string">&#x27;implementation&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里传递依赖有几种情况：<code>configurations.implementation.allDependencies</code>，<code>implementation</code>会传递所有的依赖，如果只想传递<code>api</code>依赖可以修改为<code>api</code>。<code>appendNode(&#39;scope&#39;, &#39;implementation&#39;)</code>会将原来的依赖修改为指定的的引入方式(这里是<code>implementation</code>)。</p>
<h4 id="publications"><a href="#publications" class="headerlink" title="publications"></a>publications</h4><p>　　<code>publications</code>是配置需要发布的jar的信息，publications是一个容器，类型是<code>PublicationContainer</code>，其可以配置的信息类型是<code>MavenPublication</code>。即可以理解成publications 是一个列表集合，而集合中存储的对象是<code>MavenPublication</code>，而对象的名称可以由自己随便定义。所以publications也是可以配置多个的。如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publications &#123; PublicationContainer publicationContainer -&gt;</span><br><span class="line">    <span class="comment">// 发布snapshot包</span></span><br><span class="line">    debug(MavenPublication) &#123;</span><br><span class="line">        afterEvaluate &#123; artifact(tasks.getByName(<span class="string">&quot;bundleReleaseAar&quot;</span>)) &#125;</span><br><span class="line">        groupId = <span class="string">&quot;com.xjk.basic&quot;</span></span><br><span class="line">        artifactId = <span class="string">&quot;basic&quot;</span></span><br><span class="line">        version = <span class="string">&quot;1.0.0-SNAPSHOT&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布正式包</span></span><br><span class="line">    release(MavenPublication) &#123;</span><br><span class="line">        afterEvaluate &#123; artifact(tasks.getByName(<span class="string">&quot;bundleReleaseAar&quot;</span>)) &#125;</span><br><span class="line">        groupId = <span class="string">&quot;com.xjk.basic&quot;</span></span><br><span class="line">        artifactId = <span class="string">&quot;basic&quot;</span></span><br><span class="line">        version = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置了两个发版产品，debug和release，执行发布任务后，可以在默认的本地仓库中找到正式包和测试包。</p>
<h3 id="发布到远端maven仓库"><a href="#发布到远端maven仓库" class="headerlink" title="发布到远端maven仓库"></a>发布到远端maven仓库</h3><p>发布到本地maven仓库和远端基本是一致的。唯一不同的地方就是配置仓库。以<strong>GitLab</strong>为例。我们修改<strong>repositories</strong>配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123; RepositoryHandler handler -&gt;</span><br><span class="line">    maven &#123;</span><br><span class="line">        <span class="comment">// url &quot;https://gitlab.com/api/v4/projects/projectsId(替换成自己的项目id)/packages/maven&quot;</span></span><br><span class="line">        <span class="comment">// 比如我们局域网配置的Gitlab,项目id为161的路径</span></span><br><span class="line">        url <span class="string">&quot;http://192.168.2.3:1080/api/v4/projects/161/packages/maven&quot;</span></span><br><span class="line">        <span class="comment">// 使用http仓库需要指定为true。https时不需要写这一行</span></span><br><span class="line">        allowInsecureProtocol = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 名称随意(根据Token获取的来填就行)</span></span><br><span class="line">        name <span class="string">&quot;XjkBasic&quot;</span></span><br><span class="line">        credentials(HttpHeaderCredentials) &#123;</span><br><span class="line">            name = <span class="string">&#x27;Deploy-Token&#x27;</span></span><br><span class="line">            value = <span class="string">&#x27;Deploy-Token(后面会讲怎么获取)&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        authentication &#123;</span><br><span class="line">            header(HttpHeaderAuthentication)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样运行publish就可以发送到远端了。</p>
<h4 id="获取Deploy-Token-value"><a href="#获取Deploy-Token-value" class="headerlink" title="获取Deploy-Token-value"></a>获取Deploy-Token-value</h4><p>打开Gitlab上对应的库工程项目，进入setting-&gt;Repository-&gt;Deploy tokens-&gt;填写信息-&gt;create deploy token。</p>
<img src="https://s2.loli.net/2023/02/01/lQ6SkZ9RYdjKz2n.jpg" alt="获取tokens" style="zoom:100%;" />



<p>这样就可以获取到对应的Deploy tokens</p>
<img src="https://s2.loli.net/2023/02/01/mUAMF9E1Dle2Vvf.jpg" alt="token value" style="zoom:100%;" />

<h4 id="查看远端仓库"><a href="#查看远端仓库" class="headerlink" title="查看远端仓库"></a>查看远端仓库</h4><p>可以通过Gitlab查看远端仓库，就可以看到我们刚才创建的远端仓库了。</p>
<img src="https://s2.loli.net/2023/02/01/81FZfmtvGPd5xnc.jpg" alt="maven" style="zoom:100%;" />

<h4 id="依赖远端仓库"><a href="#依赖远端仓库" class="headerlink" title="依赖远端仓库"></a>依赖远端仓库</h4><p>别的项目使用这个工程需要在现在工程的<code>build.gradle</code>（gradle7.0以上为<code>settings.gradle</code>）中添加：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">maven &#123; </span><br><span class="line">    allowInsecureProtocol = <span class="literal">true</span></span><br><span class="line">    url <span class="string">&quot;http://192.168.2.3:1080/api/v4/projects/85/packages/maven&quot;</span></span><br><span class="line">    name <span class="string">&quot;XjkBasic&quot;</span></span><br><span class="line">    credentials(HttpHeaderCredentials) &#123;</span><br><span class="line">        name = <span class="string">&#x27;Deploy-Token&#x27;</span></span><br><span class="line">        value = <span class="string">&#x27;***********&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    authentication &#123;</span><br><span class="line">        header(HttpHeaderAuthentication)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就全部结束咯！</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>发布的库工程</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;maven-publish&quot;</span></span><br><span class="line"></span><br><span class="line">task sourceJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    archiveClassifier = <span class="string">&quot;sources&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    <span class="comment">// 配置maven 仓库</span></span><br><span class="line">    repositories &#123; RepositoryHandler handler -&gt;</span><br><span class="line">        <span class="comment">// 发布到默认的 本地maven 仓库 ，路径： USER_HOME/.m2/repository/</span></span><br><span class="line">        <span class="comment">// handler.mavenLocal()</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="comment">// url &quot;https://gitlab.com/api/v4/projects/projectsId/packages/maven&quot;</span></span><br><span class="line">            url <span class="string">&quot;http://192.168.2.3:1080/api/v4/projects/161/packages/maven&quot;</span></span><br><span class="line">            allowInsecureProtocol = <span class="literal">true</span></span><br><span class="line">            name <span class="string">&quot;XjkBasic&quot;</span></span><br><span class="line">            credentials(HttpHeaderCredentials) &#123;</span><br><span class="line">                name = <span class="string">&#x27;Deploy-Token&#x27;</span></span><br><span class="line">                value = <span class="string">&#x27;************&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            authentication &#123;</span><br><span class="line">                header(HttpHeaderAuthentication)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置发布产物</span></span><br><span class="line">    publications &#123; PublicationContainer publication -&gt;</span><br><span class="line">        <span class="comment">// 名称可以随便定义</span></span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            <span class="comment">// 依赖 bundleReleaseAar 任务，并上传其产出的aar</span></span><br><span class="line">            <span class="comment">// 方式一：生成aar包 </span></span><br><span class="line">            afterEvaluate &#123; artifact(tasks.getByName(<span class="string">&quot;bundleReleaseAar&quot;</span>)) &#125;</span><br><span class="line">            <span class="comment">// 方式二：指定生成的aar路径</span></span><br><span class="line">            <span class="comment">// artifact &quot;$buildDir/outputs/aar/$&#123;project.name&#125;-release.aar&quot;</span></span><br><span class="line"></span><br><span class="line">            artifact sourceJar <span class="comment">// 增加上传源码的 task</span></span><br><span class="line"></span><br><span class="line">            groupId = <span class="string">&quot;com.xjk.basic&quot;</span></span><br><span class="line">            artifactId = <span class="string">&quot;basic&quot;</span></span><br><span class="line">            version = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// pom文件中声明依赖，从而传递到使用方</span></span><br><span class="line">            pom.withXml &#123;</span><br><span class="line">                <span class="keyword">def</span> dependenciesNode = asNode().appendNode(<span class="string">&#x27;dependencies&#x27;</span>)</span><br><span class="line">                configurations.api.allDependencies.each &#123;</span><br><span class="line">                    <span class="comment">// 避免出现空节点或 artifactId=unspecified 的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (it.group != <span class="literal">null</span> &amp;&amp; (it.name != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;unspecified&quot;</span> != it.name) &amp;&amp; it.version != <span class="literal">null</span>) &#123;</span><br><span class="line">                        println <span class="string">&quot;dependency=$&#123;it.toString()&#125;&quot;</span></span><br><span class="line">                        <span class="keyword">def</span> dependencyNode = dependenciesNode.appendNode(<span class="string">&#x27;dependency&#x27;</span>)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;groupId&#x27;</span>, it.group)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;artifactId&#x27;</span>, it.name)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;version&#x27;</span>, it.version)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;scope&#x27;</span>, <span class="string">&#x27;api&#x27;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖的工程</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工程配置</span></span><br><span class="line">maven &#123; </span><br><span class="line">    allowInsecureProtocol = <span class="literal">true</span></span><br><span class="line">    url <span class="string">&quot;http://192.168.2.3:1080/api/v4/projects/85/packages/maven&quot;</span></span><br><span class="line">    name <span class="string">&quot;XjkBasic&quot;</span></span><br><span class="line">    credentials(HttpHeaderCredentials) &#123;</span><br><span class="line">        name = <span class="string">&#x27;Deploy-Token&#x27;</span></span><br><span class="line">        value = <span class="string">&#x27;***********&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    authentication &#123;</span><br><span class="line">        header(HttpHeaderAuthentication)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块下的build.gradle</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">	.....</span><br><span class="line">    implementation <span class="string">&#x27;com.xjk.basic:basic:1.0.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>　　在高版本的Android Gradle(3.6.0以上)插件中对<code>maven-publish</code>插件有了更好的支持，我们可以简化上述的配置。配置发布的内容和依赖传递可以交给Android Gradle来进行：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="comment">// components.release 只有在配置完成之后，才能拿到值</span></span><br><span class="line">    publishing &#123;</span><br><span class="line">        <span class="comment">// 配置maven仓库</span></span><br><span class="line">        repositories &#123; RepositoryHandler handler -&gt;</span><br><span class="line">            handler.mavenLocal()</span><br><span class="line">        &#125;</span><br><span class="line">        publications &#123; PublicationContainer publicationContainer -&gt;</span><br><span class="line">            maven(MavenPublication) &#123;</span><br><span class="line">                <span class="comment">// Note1:使用 Android Gradle 插件生成的组件，作为发布的内容</span></span><br><span class="line">                from components.release</span><br><span class="line">                <span class="comment">// 上传源码</span></span><br><span class="line">                artifact sourceJar</span><br><span class="line">                groupId = <span class="string">&quot;com.xjk.basic&quot;</span></span><br><span class="line">                artifactId = <span class="string">&quot;basic&quot;</span></span><br><span class="line">                version = <span class="string">&quot;0.0.8&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如上所示，在Note1处通过from方法设置发布的内容是Android Gradle插件生成的组件。这样指定之后就不需要我们手动添加依赖信息，aar包也可以正常上传。通过查看<code>.pom</code>文件可以查看依赖项，这里需要注意的是<code>components</code>组件信息，只有在Gradle配置完成之后，才能够拿到，所以在使用的时候，需要放在 <code>afterEvaluate</code>闭包内。</p>
<p>　　这两种方式生成的<code>.pom</code>文件是有区别的，具体可以打开文件查看。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Room数据持久化</title>
    <url>/2021/04/06/room/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　SQLite代码写起来繁琐而且容易出错。始终不如ORM框架（ 对象-关系映射Object/Relation Mapping，简称ORM）来的舒服。在使用上Room数据库不如ObjectBox等NoSQL数据库使用更直观、更方便。但是ObjectBox的上手难度会更高一点。但是要是熟悉使用的话，ObjectBox我感觉会更好一点。感兴趣的也可以自行了解一哈。后续应该会出文章去讲解。</p>
<blockquote>
<p><a href="https://objectbox.io/features/">ObjectBox（速度快，全自动数据库升级，编译时检查）</a></p>
</blockquote>
<p>　　前面有点主次不分了，其实这些数据库在使用上还是有很多相似之处。下面正式介绍Room数据库：</p>
<p>　　什么是Room数据库呢？这是Google推出的数据库框架，属于ORM框架。主要是对SQLite做了一层抽象。简化了开发者对数据库的操作，其实呢，就是减少了模板代码的编写。并且支持编译时检查，并且返回支持LiveData。构成Room的主要组件包括<code>Entity </code>( 数据实体，对应数据库中的表)、<code>Dao</code>(数据访问对象，包含访问数据库的方法)、<code>Database</code>(数据库持有者)。贴一张Room不同组件之间关系的官方图：</p>
<img src="https://i.loli.net/2021/05/04/NH4j8SQqhyna1gw.png" alt="Room不同组件之间的关系" style="zoom:80%;" />

<h3 id="Room的使用"><a href="#Room的使用" class="headerlink" title="Room的使用"></a>Room的使用</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>　　在模块的build.gradle中添加如下依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> room_version = <span class="string">&quot;2.2.6&quot;</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">&quot;androidx.room:room-runtime:$room_version&quot;</span></span><br><span class="line">  kapt <span class="string">&quot;androidx.room:room-compiler:$room_version&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.room:room-ktx:$room_version&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Test helpers</span></span><br><span class="line">  testImplementation <span class="string">&quot;androidx.room:room-testing:$room_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加完成，现在可以开始使用Room数据库了。</p>
<h4 id="Entity-创建表"><a href="#Entity-创建表" class="headerlink" title="Entity(创建表)"></a>Entity(创建表)</h4><p>　　创建数据表的时候我们需要使用到<code>@Entity</code>注解。当一个类（这个类可以是普通类，也可以是data class）被当前注解标记时，会自动生成对应的数据库表单。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">&quot;fruit&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitEntity</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = false)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;fruitName&quot;</span>, defaultValue = <span class="meta-string">&quot;未知名称&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> name: String,</span><br><span class="line">    <span class="keyword">var</span> owner: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> weight: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(typeAffinity = ColumnInfo.REAL)</span></span><br><span class="line">    <span class="keyword">var</span> typeAff: String,</span><br><span class="line">    <span class="meta">@Ignore</span> <span class="comment">// 这里这样的Ignore写法是错误的，后面会讲到。这里只是为了表示有这个字段。</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面我们使用了<code>@Entity</code>来生成一个数据表，也使用很多相关的注解来辅助我们完善一张表。我们来一个一个的介绍使用到的注解。</p>
<ul>
<li><p><code>@Entity</code></p>
<p>用于注释类，tableName指定将要创建的数据库表名称，不指定默认和类名一致。其中还有<code>primaryKeys</code>和<code>foreignKeys</code>等属性用来指定主外键集合。上面代码指定主键的方式还可以写成：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(primaryKeys = [<span class="meta-string">&quot;id&quot;</span>])</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitEntity</span></span></span><br></pre></td></tr></table></figure>

<p>这样我们就不需要使用<code>@PrimaryKey</code>来注解id。autoGenerate的默认值就是<code>false</code></p>
<p>同样的外键也可以用如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(</span></span><br><span class="line"><span class="meta">    foreignKeys = [ForeignKey(</span></span><br><span class="line"><span class="meta">        entity = UserEntity::class,</span></span><br><span class="line"><span class="meta">        parentColumns = [<span class="meta-string">&quot;uid&quot;</span>],</span></span><br><span class="line"><span class="meta">        childColumns = [<span class="meta-string">&quot;owner&quot;</span>]</span></span><br><span class="line"><span class="meta">    )</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitEntity</span></span></span><br></pre></td></tr></table></figure>

<p>还有最后一个<code>indices</code>用来提高查询的效率，你可能想为特定的字段建立索引。要为一个entity添加索引，在<code>@Entity</code>注解中添加<code>indices</code>属性，列出你想放在索引或者组合索引中的字段。就像这样:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(indices = [Index(<span class="meta-string">&quot;name&quot;</span>)</span>, Index(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;owner&quot;</span>)])</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitEntity</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@PrimaryKey</code></p>
<p>用于注释属性，标识这是一个主键。除了在<code>@Entity</code>中指定外还可以使用这个注解标识主键。</p>
</li>
<li><p><code>@ForeignKey</code></p>
<p>用于注释属性，标识外键</p>
</li>
<li><p><code>@ColumnInfo</code></p>
<p>用于注释属性，这个注解我讲几个比较重要的属性。<code>name</code>和<code>typeAffinity</code>属性。<code>name</code>属性是修改当前属性值对应生成的数据库表单中生成的列名。如<code>FruitEntity</code>生成的数据库表单中列名是<code>fruitName</code>而不是<code>name</code>。</p>
<p><code>typeAffinity</code>(类型相像)是需要重点说一下的。</p>
<p>在下面描述的条件下，在查询执行阶段，数据库引擎可能会在数字存储类（INTEGER和REAL）和TEXT存储类之间转换。</p>
<ol>
<li><p>Boolean数据类型</p>
<p>SQLite没有单独的Boolean存储类，相反，Booean值以整数0（false）和1（true）存储。</p>
</li>
<li><p>日期和时间数据类型</p>
<p>SQLite没有为存储日期和/或时间设置专门的存储类，相反，内置的日期和时间函数能够把日期和时间作为TEXT，REAL或INTEGER值存储：</p>
<p>TEXT：作为ISO8601字符串（”YYYY-MM-DD HH:MM:SS.SSS”）。</p>
<p>REAL：作为Julian天数，……</p>
<p>INTEGER：作为Unix Time，即自1970-01-01 00:00:00 UTC以下的秒数。</p>
</li>
</ol>
<p>为了最大化SQLite和其他数据库引擎之间的兼容性，SQLite支持列的“类型相像”的概念。这里重要的思想是，<strong>类型是推荐的，不是必需的</strong>。任何列仍然能够存储任何类型的数据。只是某些列，能够选择优先使用某种存储类。这个对列的优先存储类称作它的“相像”。</p>
</li>
<li><p><code>@Ignore</code></p>
<p>用于注释属性，忽略该类的这个属性，数据表字段不生成对应的列。但是需要注意的是，如果你是用的是kotlin开发，被<code>@Ignore</code>注解的字段应当有默认值。不然他不知道该调用什么构造函数来实例化当前对象。既然有默认值了，就应该这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="meta-string">&quot;fruit&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitEntity</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="comment">// 前面的字段省略。。。</span></span><br><span class="line">    <span class="comment">// @JvmOverloads应该都知道什么意思吧，不知道反编译一下就知道了。</span></span><br><span class="line">    <span class="comment">// 加上@JvmOverloads编译时会生成多个构造函数。因为java不支持默认值。</span></span><br><span class="line">    <span class="comment">// 还是不理解的话可以自己反编译看看。</span></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果我不使用<code>@Ignore</code>属性就怎么写就都无所谓了。</p>
</li>
</ul>
<h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(f: <span class="type">FruitEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(<span class="keyword">vararg</span> f: <span class="type">FruitEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;select * from fruit&quot;</span>)</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">queryAll</span><span class="params">()</span></span>: List&lt;FruitEntity&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dao非常的灵活，你可以传入不同的参数。这里的入参和返回值可以根据实际的需要随便写。如果都不能满足你的要求，你还可以自己去写sql语句（自己写的sql语句都使用<code>@Query</code>注解）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="meta-string">&quot;update fruit set fruitName = &#x27;苹果&#x27; where fruitName = :name&quot;</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(name: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="meta-string">&quot;delete from fruit where fruitName = :name&quot;</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">delect</span><span class="params">(name: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="meta-string">&quot;update fruit set fruitName = &#x27;苹果&#x27; where fruitName in (:names)&quot;</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(<span class="keyword">vararg</span> names: <span class="type">String</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>除了上面这些简单的用法，你还可以返回可观察对象。就像这样:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="meta-string">&quot;select * from fruit&quot;</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">queryAll</span><span class="params">()</span></span>: LiveData&lt;List&lt;FruitEntity&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="meta-string">&quot;select * from fruit&quot;</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">queryAll</span><span class="params">()</span></span>: Flowable&lt;List&lt;FruitEntity&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="DataBase"><a href="#DataBase" class="headerlink" title="DataBase"></a>DataBase</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [FruitEntity::class], version = 1)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">fruitDao</span><span class="params">()</span></span>: FruitDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　创建好这三个组件，Room的配置基本就已经完成了，通常我们需要的业务逻辑都加写在Dao中的抽象方法中。现在只需要build一次就可以让Room帮我们自动生成对应的实现代码。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>　　现在在需要使用的地方调用如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> db = Room.databaseBuilder(applicationContext, FruitDatabase::<span class="keyword">class</span>.java, <span class="string">&quot;database.db&quot;</span>)</span><br><span class="line">	.allowMainThreadQueries()</span><br><span class="line">	.build()</span><br><span class="line">db.fruitDao().insert(FruitEntity())</span><br></pre></td></tr></table></figure>

<p>现在你就可以简单的使用Room了。</p>
<p>　　最后提一句就是Room的事务，第一种方式就是在dao类中使用<code>@Transaction</code>注释。第二种就是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">db.runInTransaction &#123;</span><br><span class="line">	db.fruitDao().update(<span class="string">&quot;苦瓜&quot;</span>, <span class="string">&quot;芒果&quot;</span>)</span><br><span class="line">	db.fruitDao().update(<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;香蕉&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>持久化</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Android存储</title>
    <url>/2022/05/29/Storage/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　在android中存在多种持久化存储方式。各种存储方式的侧重点也不尽相同，都有各自优劣，根据自己的需要选择合适的存储方式对开发至关重要。本文主要学习android的文件存储，但是也会介绍到一些其他的存储方式。</p>
<ul>
<li><p>使用SharedPreferences保存一些键值对数据</p>
<p>通常用于去记录一些用户偏好，是否保存密码等等。推荐使用MMKV来替代SharedPreferences。</p>
</li>
<li><p>使用数据库去存储一些结构数据。</p>
<p>通常用于记录一些结构化的数据，比如用户收藏列表等等。</p>
</li>
<li><p>网络存储</p>
</li>
<li><p>文件存储</p>
<p>文件存储是比其他存储方式复杂的多的一种存储方式，文件存储有几个关键结点，<code>android 4.4</code>、<code>android 6.0</code>、<code>android 10</code>、<code>android 11</code>之后我们会一一讲到。</p>
</li>
</ul>
<p>　　在学习文件存储之前，我们先要了解文件存储的一些基础知识。</p>
<h3 id="存储是如何划分的？如何访问？"><a href="#存储是如何划分的？如何访问？" class="headerlink" title="存储是如何划分的？如何访问？"></a>存储是如何划分的？如何访问？</h3><p>　　首先明确一点的是android手机的存储空间由两部分构成，分别是内部存储和外部存储。</p>
<p>　　在android 4.4之前，由于当时的技术限制，android手机的自带内存（我们暂且称为内部内存）是非常的小，完全不够用，于是为了扩大存储，我们需要将一张SD卡（Secure Digital Memory Card/SD card）插入手机来扩大存储空间。这部分也就是外部存储，这也是当时开发过程中为什么使用外部存储必须要检查外部存储是否挂载的原因。</p>
<p>　　在android 4.4之后技术突破，手机自带的内存也变得客观。可这部分自带的内存被分为了内部存储和外部存储。但是你仍然可以插入SD卡来扩大你的手机外部存储，不过很快手机厂商就在后续的android手机中移除的SD卡的卡槽。这也就成为后续的存储划分（方框大小不代表实际划分大小）。</p>
<p><img src="https://s2.loli.net/2022/05/29/tzuDNbH4jxZXygC.png" alt="存储划分"></p>
<p>　　需要注意的是<strong>内部存储和外部存储中APP私有空间在APP卸载的时候也会同时删除</strong>，这也是很多APP要在你的外部存储空间的别的地方建立文件夹存文件的原因。APP私有空间的文件不会提供给别的应用访问，属于应用独占。其他目录只要有读写权限都可以访问，但是这在android 10(API 29)中已经做出了较大的改动。接着我们看看<br>手机的内部存储是什么样的结构，</p>
<h4 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h4><p>　　以包名<code>space.lianxin.room</code>和<code>space.lianxin.storage</code>为例，</p>
<p><img src="https://s2.loli.net/2022/05/29/oRv3W8dLF1NOIxG.png" alt="内部存储"></p>
<p>可以看出我们的数据库文件和SharedPreferences文件都存放在/data/data/packageName/下面，部分手机是/data/user/0/packageName/下面。这些文件夹分别存放的数据是：</p>
<blockquote>
<p>cache ==&gt; 存放缓存文件<br>code_cache ==&gt; 存放运行时的一些代码缓存<br>databases ==&gt; 存放数据库文件<br>files ==&gt; 存放文件<br>shared_prefs ==&gt; 存放SharedPreferences 文件</p>
</blockquote>
<p>对于内部存储，我们可以通过<code>context.getCacheDir()</code>、<code>context.getCodeCacheDir()</code>、<code>context.getFileDir()</code>获取到对应的文件夹。</p>
<p>　　既然我们已经知道了如何去获取文件路径，那么接下来我们怎么去保存文件呢？文件的读写方式大致分为<strong>字节流</strong>和<strong>字符流</strong>。这里不赘述了。但是这个流程是一致的：<strong>获取路径 ==&gt; 开启文件流 ==&gt; 读写文件 ==&gt; 关闭流</strong> 。这就是一个完整的文件读写过程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取文件路径并创建文件</span></span><br><span class="line">    <span class="keyword">val</span> file = File(getFilesDir(), <span class="string">&quot;temp.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.createNewFile()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启文件流</span></span><br><span class="line">    <span class="keyword">val</span> fos = FileOutputStream(file)</span><br><span class="line">    <span class="comment">// 写文件</span></span><br><span class="line">    fos.write(<span class="string">&quot;12345&quot;</span>.toByteArray(Charsets.UTF_8))</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    fos.close()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，一个文件就保存好了，而且<strong>不需要任何权限、不需要任何权限、不需要任何权限</strong>。</p>
<h4 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h4><h5 id="APP私有目录"><a href="#APP私有目录" class="headerlink" title="APP私有目录"></a>APP私有目录</h5><p>　　这部分和内部存储基本没什么大的区别。不过是将路径改成了/sdcard/Android/data/packageName/，部分手机是/storage/emulated/0/Android/data/packageName/。获取路径的方式如下：</p>
<blockquote>
<p>context.getExternalCacheDir() // 结果: /sdcard/Android/data/space.lianxin.storage/cache<br>context.getExternalFilesDir(String) // 结果: /sdcard/Android/data/space.lianxin.storage/files</p>
</blockquote>
<p>同样的，这部分存储空间<strong>不需要任何权限，并且在软件卸载时删除</strong>。第二个方法需要一个String参数,其实就是在原本的目录下又创建了一个子文件夹并返回这个子文件夹的路径。(笔者在Android studio上调试的时候发现断点获取到的路径值是/storage/emulated/0/Android/data/packageName/，而实际操作的路径值是/sdcard/Android/data/packageName/。其实这两个路径是同一个值)。</p>
<p>　　别看APP私有目录和内部存储那么像，其差异还是存在的。几点概括就是：</p>
<ul>
<li><p>内部存储用于存储容量较小，私密性强的文件。</p>
</li>
<li><p>APP私有目录用于存储容量较大的文件</p>
</li>
<li><p>两者均APP独占，无需任何权限</p>
</li>
<li><p>APP卸载后，两者存储的数据均会被删除</p>
</li>
<li><p>只有这两个目录下的文件最终会被算到 设置-缓存 中</p>
</li>
<li><p>用户清除缓存时，两者的cache和code_cache文件夹下的文件会被清除</p>
</li>
<li><p>用户清除数据时，两者的所有数据会被清除</p>
</li>
</ul>
<h5 id="公共目录（媒体文件和文档-其它文件）"><a href="#公共目录（媒体文件和文档-其它文件）" class="headerlink" title="公共目录（媒体文件和文档/其它文件）"></a>公共目录（媒体文件和文档/其它文件）</h5><p>　　公共目录<strong>需要存储权限</strong>才能够进行访问，这也是本文介绍的重点。</p>
<h3 id="存储权限"><a href="#存储权限" class="headerlink" title="存储权限"></a>存储权限</h3><p>　　存储权限可以大体的分为三个阶段：第一阶段是android 4.4之前。开发者只需要在清单文件(AndroidManifest.xml)中声明即可，就像这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二个阶段是android 6.0开始，除了需要在清单文件中声明之外，还需要动态的去申请权限。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册存储权限申请</span></span><br><span class="line">    registerPermissionStorage =</span><br><span class="line">    	registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) &#123;</span><br><span class="line">            <span class="comment">// 请求结果的回调</span></span><br><span class="line">            binding.tvDisplay.text = <span class="string">&quot;存储权限获取结果为：<span class="variable">$it</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 发起请求</span></span><br><span class="line">    registerPermissionLocation.launch(</span><br><span class="line">        arrayOf(</span><br><span class="line">            Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">            Manifest.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式（不推荐）</span></span><br><span class="line"><span class="comment">// 先申请权限，然后重写onRequestPermissionsResult方法。</span></span><br><span class="line">ActivityCompat.requestPermissions(</span><br><span class="line">    activity,</span><br><span class="line">    arrayOf(</span><br><span class="line">        Manifest.permission.ACCESS_COARSE_LOCATION,</span><br><span class="line">        Manifest.permission.ACCESS_FINE_LOCATION</span><br><span class="line">    ),</span><br><span class="line">    REQUEST_CODE_STORAGE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>最后一个阶段就是Android 10开始的分区存储。</p>
<h3 id="Android-10之前的访问方式"><a href="#Android-10之前的访问方式" class="headerlink" title="Android 10之前的访问方式"></a>Android 10之前的访问方式</h3><h4 id="媒体文件"><a href="#媒体文件" class="headerlink" title="媒体文件"></a>媒体文件</h4><p>　　访问媒体文件目的还是需要拿到文件的路径，获取文件流。主要的方式有三种方式：</p>
<p>第一种：直接构建路径。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMedia1</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED) &#123;</span><br><span class="line">            <span class="keyword">val</span> path = Environment.getExternalStorageDirectory()</span><br><span class="line">            <span class="keyword">val</span> imgPath = <span class="string">&quot;<span class="subst">$&#123;path&#125;</span><span class="subst">$&#123;File.separator&#125;</span><span class="subst">$&#123;Environment.DIRECTORY_DCIM&#125;</span><span class="subst">$&#123;File.separator&#125;</span>123.jpg&quot;</span></span><br><span class="line">            <span class="keyword">return</span> BitmapFactory.decodeFile(imgPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式：通过<strong>MediaStore</strong>获取路径</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMedia2</span><span class="params">(context: <span class="type">Context</span>)</span></span>: List&lt;Bitmap&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> resolver = context.contentResolver</span><br><span class="line">    <span class="keyword">val</span> cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;Bitmap&gt;()</span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> imgPath = cursor.getStringOrNull(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA))</span><br><span class="line">        imgPath?.let &#123;</span><br><span class="line">            result.add(BitmapFactory.decodeFile(it))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方式：通过<strong>MediaStore</strong>获取Uri，和第二种方法相似。拿到Uri之后再处理就可以获取到媒体文件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = cursor.getLongOrNull(cursor.getColumnIndex(MediaStore.MediaColumns._ID)) ?: <span class="number">0L</span></span><br><span class="line">    <span class="keyword">val</span> uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h4><p>　　其他文件也可以直接构建路径的方式去访问，不赘述了。第二种方式就是打开文件选择器，然后去选择文件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式（不推荐）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)</span><br><span class="line">    	.addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    	.setType(<span class="string">&quot;imaga/jpg&quot;</span>)</span><br><span class="line">    startActivityForResult(intent, <span class="number">201</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">201</span> &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        openUri(<span class="keyword">data</span>.<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过uri构建图片文件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openUri</span><span class="params">(uri: <span class="type">Uri</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uri == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> fis = contentResolver.openInputStream(uri)</span><br><span class="line">        <span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(fis)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">registerForActivityResult(ActivityResultContracts.OpenDocument()) &#123;</span><br><span class="line">    openUri(it)</span><br><span class="line">&#125;.launch(arrayOf(<span class="string">&quot;image/jpg&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>　　直接构建路径，<code>File.mkdirs()</code>创建好文件，然后保存自己的文件。</p>
<h3 id="Android-10变更"><a href="#Android-10变更" class="headerlink" title="Android 10变更"></a>Android 10变更</h3><h4 id="为什么要变更？"><a href="#为什么要变更？" class="headerlink" title="为什么要变更？"></a>为什么要变更？</h4><p>　　在外部存储的文件，不会被统计到 设置-缓存 中去，软件卸载的时候也就不会清除这些垃圾，还有许多软件管杀不管埋（在/sdcard/新建自己的文件夹确实方便操作文件，但是又不去清理），导致手机越用内存越小。同样的，因为谁都可以访问外部存储空间，这样就导致数据不安全。</p>
<h4 id="变更了那些地方？"><a href="#变更了那些地方？" class="headerlink" title="变更了那些地方？"></a>变更了那些地方？</h4><p>　　<strong>外部存储媒体文件、文档和其他目录文件不能使用路径直接访问文件</strong>、而是需要通过Uri访问（也就是内部存储和APP私有空间还是没啥变化）。共享存储空间存放的是图片、视频、音频等文件，这些资源是公用的，所有App都能够访问它们。系统里有external.db数据库，该数据库里有files表，该表里存放着共享文件的诸多信息，如图片有宽高，经纬度、存放路径等，视频宽高、时长、存放路径等。而文件真正存放的地方在于共享存储空间。</p>
<p><strong>现在保存图片到相册</strong>，简单流程如下：</p>
<ol>
<li><p>将路径信息写入数据库里，并获取Uri</p>
</li>
<li><p>通过Uri构造输出流</p>
</li>
<li><p>将该图片保存在/sdcard/Pictures/目录下</p>
</li>
</ol>
<p>从相册<strong>获取图片</strong>，简单流程如下：</p>
<ol>
<li><p>先查询数据库，找到对应的图片Cursor</p>
</li>
<li><p>从Cursor里构造Uri</p>
</li>
<li><p>从Uri构造输入流读取图片</p>
</li>
</ol>
<p>这套流程对音频和视频同样适用。</p>
<h4 id="MediaStore作用"><a href="#MediaStore作用" class="headerlink" title="MediaStore作用"></a>MediaStore作用</h4><p>　　共享存储空间里存放着图片、视频、音频、下载的文件，App获取或者插入文件的时候怎么区分这些类型呢？<br>这个时候就需要MediaStore。MediaStore（Api 29）的结构大致如下。</p>
<blockquote>
<p>MediaStore<br>　　| - Audio<br>　　| - DownloadColumns<br>　　| - Downloads<br>　　| - Files<br>　　| - Images<br>　　| - InternalThumbnails (@Deprecated)<br>　　| - MediaColumns<br>　　| - PendingParams (@Deprecated)<br>　　| - PendingSession (@Deprecated)<br>　　| - ThumbnailConstants<br>　　| - Video</p>
</blockquote>
<p>　　可以看出其内部有Audio、Images等内部类，这些内部类里记录着files表的各个字段名，通过构造这些参数就可以插入相应的字段值以及获取对应的字段值。MediaStore 实际上就是相当于给各个字段起了别名，我们编码的时候更容易记住与使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Audio</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio metadata columns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AudioColumns</span> <span class="keyword">extends</span> <span class="title">MediaColumns</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A non human readable key calculated from the TITLE, used for</span></span><br><span class="line"><span class="comment">         * searching, sorting and grouping</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Column(value = Cursor.FIELD_TYPE_STRING, readOnly = true)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TITLE_KEY = <span class="string">&quot;title_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** <span class="doctag">@removed</span> promoted to parent interface */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION = <span class="string">&quot;duration&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The position within the audio item at which playback should be</span></span><br><span class="line"><span class="comment">         * resumed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@DurationMillisLong</span></span><br><span class="line">        <span class="meta">@Column(Cursor.FIELD_TYPE_INTEGER)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOKMARK = <span class="string">&quot;bookmark&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The id of the artist who created the audio file, if any</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Column(value = Cursor.FIELD_TYPE_INTEGER, readOnly = true)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARTIST_ID = <span class="string">&quot;artist_id&quot;</span>;</span><br><span class="line">        <span class="comment">// ....等等。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MediaStore和Uri联系"><a href="#MediaStore和Uri联系" class="headerlink" title="MediaStore和Uri联系"></a>MediaStore和Uri联系</h4><p><img src="https://s2.loli.net/2022/05/29/mZtQiY7vGLClfIF.png" alt="MediaStore和Uri联系"></p>
<p>比如想要查询共享存储空间里的图片文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p><code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code> 意思是指定查询文件的类型是图片，并构造成Uri对象，Uri实现了Parcelable，能够在进程间传递。接收方(另一个进程收到后)，匹配Uri，解析出对应的字段，进行具体的操作。当然，MediaStore是系统提供的方便操作共享存储空间的类，若是自己写ContentProvider，则也可以自定义类似MediaStore的类用来标记自己的数据库表的字段。</p>
<h4 id="通过Uri读取和写入文件"><a href="#通过Uri读取和写入文件" class="headerlink" title="通过Uri读取和写入文件"></a>通过Uri读取和写入文件</h4><p>　　既然不能通过路径直接访问文件，那么来看看如何通过Uri访问文件(虽然也可以通过文件路径直接构造Uri，但是此种方式构造的Uri是没有权限访问文件的)。</p>
<ul>
<li><strong>读取文件</strong></li>
</ul>
<p>　　比如说我在<code>/sdcard/mytest.txt</code>有一个文件，如果我们按照之前的写法，会报权限错误；而<code>mytest.txt</code>不属于共享存储空间的文件，是属于其它目录的，因此又不能通过MediaStore获取。我们只能通过SAF获取。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    registerForActivityResult(ActivityResultContracts.OpenDocument()) &#123;</span><br><span class="line">        openUri(it)</span><br><span class="line">    &#125;.launch(arrayOf(<span class="string">&quot;text/plain&quot;</span>))    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openUri</span><span class="params">(uri: <span class="type">Uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inputStream = contentResolver.openInputStream(uri)</span><br><span class="line">        <span class="comment">// 拿到流，做该做的的事咯</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件的读取就没有问题了。</p>
<ul>
<li><strong>写入文件</strong></li>
</ul>
<p>　　写文件和读文件都是差不多的代码。拿到文件流就向文件中写数据。我怎么在这个文件下面创建文件呢？<strong>达咩，达咩，达咩</strong>。</p>
<h4 id="通过Uri-获取图片和插入相册"><a href="#通过Uri-获取图片和插入相册" class="headerlink" title="通过Uri 获取图片和插入相册"></a>通过Uri 获取图片和插入相册</h4><p>　　上面列举出了其它目录下文件的读写，方法是通过SAF拿到Uri。SAF好处是：系统提供了文件选择器，调用者只需要指定想要读写的文件类型，比如文本类型、图片类型、视频类型等，选择器就会过滤出相应文件以供选择。接入方便，选择简单。</p>
<p>　　但是如果需要自己实现相册选择器，那么就需要获得共享存储空间下的文件信息。此种场景下使用SAF是无法做到的。因此问题的关键是：<strong>如何批量获得共享存储空间下图片/视频的信息？</strong>答案是：ContentResolver+ContentProvider+MediaStore(ContentProvider对于调用者是透明的)。<br>以图片为例，分析插入与查询方式。</p>
<ul>
<li><strong>插入相册</strong></li>
</ul>
<p>　　图片插入相册的完整流程如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertPic</span><span class="params">(inputStream: <span class="type">InputStream</span>, fileName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> values = ContentValues()</span><br><span class="line">    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME, fileName)</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        values.put(MediaStore.Images.ImageColumns.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> path = Environment.getExternalStorageState() +</span><br><span class="line">        	File.separator + Environment.DIRECTORY_PICTURES +</span><br><span class="line">        	File.separator + fileName</span><br><span class="line">        <span class="comment">// MediaStore.Images.ImageColumns.DATA已经废弃了。</span></span><br><span class="line">        values.put(MediaStore.Images.ImageColumns.DATA, path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入相册</span></span><br><span class="line">    <span class="keyword">val</span> uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    writeFile(uri, inputStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeFile</span><span class="params">(uri: <span class="type">Uri</span>?, inputStream: <span class="type">InputStream</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> outputStream = contentResolver.openOutputStream(uri)</span><br><span class="line">        <span class="comment">// 拿到写入流，该干啥干啥。</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里有几处需要说明。</p>
<p>　　第一：Android 10.0之前，<code>MediaStore.Images.ImageColumns.DATA</code> 字段记录的是图片的<strong>绝对路径</strong>，而Android 10.0(含)之后，DATA 被废弃，取而代之的是使用<code>MediaStore.Images.ImageColumns.RELATIVE_PATH</code>，表示<strong>相对路径</strong>。比如指定RELATIVE_PATH为Environment.DIRECTORY_PICTURES，表示之后的图片将会放到Environment.DIRECTORY_PICTURES目录下。　　　　　　</p>
<p>　　第二：调用ContentResolver里的方法插入相册。<code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code> 指的是插入图片表。ContentValues 以Map的形式记录了待写入的字段值。插入后返回Uri。</p>
<p>　　第三：以上两步仅仅只是往数据库里增加一条记录，该记录指向的新文件是空的，需要将图片写入到新文件。而新文件位于<code>/sdcard/Pictures/</code>目录下，该目录是不能直接通过路径访问的，因此需要通过第二步返回的Uri进行访问。</p>
<ul>
<li><strong>获取图片</strong></li>
</ul>
<p>　　获取图片现在只能通过之前讲到的通过<code>MediaStore</code>去获取Uri，再构建文件流，从流中读取文件。</p>
<p>　　以上，通过Uri 获取图片和插入相册分析完毕，共享存储空间的其他文件类型如视频、音频、下载文件也是同样的流程。</p>
<h3 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h3><p>　　通过Uri访问文件似乎已经满足了Android 10.0适配要求，但是仔细想想还是有不足之处：</p>
<ul>
<li>共享存储空间只能通过MediaStore访问，以前流行的访问方式是直接通过路径访问。比如自己做的相册管理器，先遍历相册拿到图片/视频的路径，然后再解析成Bitmap展示，现在需要先拿到Uri，再解析成Bitmap，多少有些不方便。此外，也许你依赖的第三方库是直接通过路径访问文件的，而三方库又没有及时更新适配分区存储，可能就会导致用不了相应的功能。</li>
<li>SAF虽然能够访问其它目录的文件，但是每次都需要跳转到新的页面去选择，当想要批量展示文件的时候，比如自己做的文件管理器，就需要列出当前目录下有哪些目录/文件，这个时候需要有权限遍历/sdcard/目录。显然，SAF并不能胜任此工作。</li>
</ul>
<p>Android 11.0考虑到上面的问题，因此做了新的优化。</p>
<h4 id="共享存储空间-媒体文件访问变更"><a href="#共享存储空间-媒体文件访问变更" class="headerlink" title="共享存储空间-媒体文件访问变更"></a>共享存储空间-媒体文件访问变更</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getImagePath</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA)</span><br><span class="line">            <span class="keyword">val</span> path = cursor.getString(index)</span><br><span class="line">            <span class="keyword">val</span> bitmap = BitmapFactory.decodeFile(path)</span><br><span class="line">            <span class="comment">// 图片操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　可以看出，之前在Android 10.0上被禁用的访问方式，在Android 11.0上又被允许了，这就解决了上面的第一个问题。需要注意的是：此种方式只允许读文件，<strong>写文件依然不行</strong>。</p>
<blockquote>
<p>Google 官方指导意见是：虽然可以通过路径直接访问媒体文件，但是这些操作最终是被重定向到MediaStore API的，重定向过程可能会损耗一些性能，并且直接通过路径访问不一定比MediaStore API 访问快。总之建议非必要的话不要直接使用路径访问。</p>
</blockquote>
<h4 id="访问所有文件"><a href="#访问所有文件" class="headerlink" title="访问所有文件"></a>访问所有文件</h4><p>　　假若App开启了分区存储功能，当App运行在Android 10.0的设备上时，是没法遍历/sdcard/目录的。而在Android 11.0上运行时是可以遍历的，需要进行如下几个步骤。</p>
<ol>
<li>在AndroidManifest.xml添加权限声明</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>动态申请权限（这里申请的不是弹框告知，而是跳到了新的界面，由用户开启）</li>
<li>这样就可以像android之前一样去读写文件了。</li>
</ol>
<p>另外有一点如果android 10想想android 10之前一样访问文件，只需要在清单文件的<code>application</code>下加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:requestLegacyExternalStorage=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到这里文件存储适配就讲完了，变动简单来说就是不能再使用绝对路径去访问文件，没有授权的文件区域，也不在提供读写权限。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>持久化</tag>
        <tag>适配</tag>
      </tags>
  </entry>
</search>
