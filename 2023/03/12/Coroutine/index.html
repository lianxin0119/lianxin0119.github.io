<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Kotlin协程-使用篇 | 恋心</title><meta name="keywords" content="异步,协程,结构化并发"><meta name="author" content="恋心,qingyizhuyin@qq.com"><meta name="copyright" content="恋心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="协程是一个比线程更加轻量级的存在，我们可以在某个地方直接挂起，转而去执行另一段函数，并且可以返回至挂起处继续执行。在处理异步任务的时候十分滴优雅。">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程-使用篇">
<meta property="og:url" content="http://lianxin.space/2023/03/12/Coroutine/index.html">
<meta property="og:site_name" content="恋心">
<meta property="og:description" content="协程是一个比线程更加轻量级的存在，我们可以在某个地方直接挂起，转而去执行另一段函数，并且可以返回至挂起处继续执行。在处理异步任务的时候十分滴优雅。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/03/12/k9oRDIGfHK1cuse.jpg">
<meta property="article:published_time" content="2023-03-12T08:14:00.000Z">
<meta property="article:modified_time" content="2023-03-26T08:50:22.186Z">
<meta property="article:author" content="恋心">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="协程">
<meta property="article:tag" content="结构化并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/03/12/k9oRDIGfHK1cuse.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lianxin.space/2023/03/12/Coroutine/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin协程-使用篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-26 16:50:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/02/26/6htEVf4X7aIqLxk.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/03/12/k9oRDIGfHK1cuse.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">恋心</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kotlin协程-使用篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-12T08:14:00.000Z" title="发表于 2023-03-12 16:14:00">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kotlin/">Kotlin</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>　　在阅读之前，我认为你对与Kotlin的操作符重载、高阶函数、扩展函数以及多线程都有一定的了解认识，在这个基础之上我们进行协程的学习。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　协程（Coroutines）不是Kotlin独有的，也不是Kotlin提出来的新概念，它早在1958年就被发明并且用于构建汇编程序。这说明协程是一种<strong>编程思想</strong>，并不局限于某种特定的语言。其他的一些编程语言，如Go、Python等都可以在语言层面上实现协程，甚至是Java也可以通过扩展库实现协程。网上对于协程的定义也有很多：</p>
<ul>
<li>协程是轻量级线程（官方文档）</li>
<li>协程运行在用户态，线程运行在内核态</li>
<li>协程是协作式的，线程是抢占式的</li>
<li>协程是一套线程框架（扔物线的表述）</li>
</ul>
<p>　　上诉定义的差异是看待协程的角度是不同，而我们作为一个Android开发者，要理解Kotlin协程，应该从一个Android开发者的角度来理解协程。协程虽然并不直接和操作系统打交道，但是协程是运行在线程之中，依赖于线程的。不过协程的挂起是<strong>不需要阻塞线程，几乎无代价并且是由开发者控制的</strong>。所以说协程更像是用户态的线程。</p>
<p>　　对比一个进程可以创建多个线程一样，一个线程是可以创建多个协程的。它的设计初衷是<strong>为了解决多并发和并发之间的协作</strong>问题，程序的逻辑可以在协程中顺序的表达，而底层库为我们去解决异步性。简单来说就是<strong>以顺序的编码去实现异步执行的代码</strong>。这样听起来协程和线程的作用差不多类似，在官方文档的介绍中也可以看到协程和线程的对比实现。因此我们可以带入线程的角度去理解协程。</p>
<p>　　总而言之：协程可以简化异步编程，可以顺序的表达程序。它提供了一种避免阻塞线程并且更廉价、更可控的操作替代线程阻塞的方法-<strong>协程挂起</strong>。</p>
<p>　　<strong>挂起</strong>是协程中一个很重要的理念。</p>
<h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>　　我们可以先说一说使用协程在Android开发中的优势，但是我们现在不一定要全部理解这些优势，因为在后面介绍和使用中，我们自己也能总结出来协程的优势。现在有个大概印象就好。</p>
<ul>
<li><p><strong>很容易切换到子线程</strong></p>
<p>我们有许多方法可以让操作远离主线程，<code>ExecutorServices</code>、<code>AsyncTask</code>、<code>Loaders</code>等等，但都不如协程来的轻松，并且在处理业务逻辑时可以顺序书写代码，没有累人的回调。</p>
</li>
<li><p><strong>协程是挂起式的而不是阻塞式的</strong></p>
<p>挂起函数挂起协程时，不会阻塞协程所在的线程，它会将自己先从线程中脱离出去，让线程去干其他的事情。挂起函数执行完成后会自动恢复协程，后面的代码才会继续执行。</p>
</li>
<li><p><strong>编译器会检测调用</strong></p>
<p>当一个挂起函数被调用时，编译器会检测该函数的调用环境是否是一个协程上下文的环境。</p>
</li>
<li><p><strong>结构化并发</strong></p>
<p>想象一种情况，我们进一个页面需要连续请求几个接口，当其中一个网络请求出错时或者此时退出页面，我们希望关闭其他并行的网络请求。如果用Rx实现，则需要使用zip操作符进行合并请求，然后持有zip返回的对象，在<code>destory</code>的时候销毁。然而协程只需要你取消持有的最顶层上下文，那么其所有的上下文就都会被取消。</p>
<p>如果一个接口需要依赖另一个接口返回的结果同样会很麻烦。</p>
</li>
<li><p><strong>协程是轻量级的</strong></p>
<p>我们可以很轻松的创建十万个协程，但是创建十万个线程（会OOM）基本不现实。</p>
</li>
</ul>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>　　这里所说的重要概念和上面说的优势一样，现在只需要有个大致印象就OK。在了解完使用之后会进行详细介绍。</p>
<ul>
<li><code>CoroutineScope</code></li>
</ul>
<p>　　协程作用域（<code>CoroutineScope</code>），可以理解为协程本身。包含了协程上下文（<code>CoroutineContext</code>）。<strong>每个协程构建器(如<code>launch</code>、<code>async</code>等)都是<code>CoroutineScope</code>的扩展</strong>，并继承其<code>coroutineContext</code>以自动传播其所有元素和取消。获得作用域的独立实例的最佳方法是<code>CoroutineScope()</code>和<code>MainScope()</code>工厂函数(这两个函数是top-level函数)，注意在不再需要这些协程作用域时要取消它们。可以使用<strong>加号操作符</strong>将其它上下文元素追加到作用域。（官方表述）</p>
<ul>
<li><code>CoroutineContext</code></li>
</ul>
<p>　　协程上下文（<code>CoroutineContext</code>）是一些元素的集合，主要包括<code>Job</code>和<code>CoroutineDispatcher</code>元素。可以代表一个协程具体的运行场景。</p>
<ul>
<li><code>CoroutineDispatcher</code></li>
</ul>
<p>　　协程调度器（<code>CoroutineDispatcher</code>）决定协程所在的线程或者线程池。如果不指定调度器，就会在当前线程运行。目前提供了四种默认实现，<code>Dispatchers.Default</code>、<code>Dispatchers.IO</code>、<code>Dispatchers.Unconfined</code>、<code>Dispatchers.Main</code>。</p>
<ul>
<li><code>EmptyCoroutineContext</code></li>
</ul>
<p>　　<code>EmptyCoroutineContext</code>空的协程上下文，当存在有父协程时，使用该上下文启动一个子协程则会继承父协程的上下文，即在父协程的线程上执行代码。若不在父协程，则会在<code>Default</code>的线程池中获取编号为一的线程。</p>
<h3 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h3><p>　　为了方便观察代码运行所在的线程，我们定义一个全局的<code>log</code>函数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(log: <span class="type">CharSequence</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> threadName = Thread.currentThread().name</span><br><span class="line">    <span class="comment">// kotlin程序就是: println(&quot;[$threadName] $log&quot;)</span></span><br><span class="line">    Log.e(<span class="string">&quot;lianxin&quot;</span>, <span class="string">&quot;[<span class="variable">$threadName</span>] <span class="variable">$log</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h4><p>　　Kotlin并没有把协程放入到标准库API当中去，而是做成了一个三方的依赖库，即使它很小。所以，我们第一步就应该把协程引入项目，需要注意的是核心库和平台库的版本需要保持一致。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心库, 必须依赖</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&#x27;</span></span><br><span class="line"><span class="comment">// Android平台库</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><p>协程需要运行在一个有协程上下文的环境中，在非协程环境中从无到有的协程创建有三种方式：</p>
<ol>
<li><p><code>runBlocking&#123;&#125;</code></p>
<p>　这是一个协程构建器，作用是在指定线程或线程池（未指定就是当前线程）创建一个新的协程，并且<strong>阻塞当前线程</strong>，直到闭包逻辑以及所有的子协程全部执行完毕，返回结果。才会继续执行后续逻辑。在项目的实际使用中<strong>不推荐</strong>使用这种创建方式，主要还是为<code>main</code>函数和单元测试设计的。</p>
</li>
<li><p><code>GlobalScope</code> + 构建器</p>
<p>　启动一个和应用生命周期一致的顶级协程，并且不会阻塞当前线程。应用生命结束时，如果协程还存在未执行完的部分会直接结束执行，所以并不能使用它保活进程，它更像是一个守护线程。</p>
<p> 因为它创建的协程是和应用生命周期一致，所以存在启动它的组件已经销毁但是协程依然存在的情况，极端情况（频繁创建销毁组件等）下可能导致资源耗尽的情况，而且由它创建的协程无法被动取消。综上，在Android的项目开发中也<strong>不推荐</strong>使用这种创建方式，除非你很明确你就是要创建顶级协程并且能够管理好它们。</p>
</li>
<li><p>实现<code>CoroutineScope</code> + 构建器</p>
<p>　既然上面的创建方式都不推荐，那这个肯定就是推荐的协程使用方式。给组件实现<code>CoroutieScope</code>接口，通过接口中的<code>CoroutineContext</code>对象去管理所有的协程。</p>
<p>协程的构建器主要是<code>launch&#123;&#125;</code>和<code>async&#123;&#125;</code>函数。<code>launch</code>返回的是<code>Job</code>对象，<code>async</code>返回的是<code>Job</code>的子类<code>Deferred</code>对象，<code>Deferred</code>额外实现了<code>await()</code>方法用于获取结果，可以阻塞线程直到获取到结果。</p>
</li>
</ol>
<h4 id="第一个协程实例"><a href="#第一个协程实例" class="headerlink" title="第一个协程实例"></a>第一个协程实例</h4><p>　　这里我们没有使用Android环境，而是直接用的kotlin项目，因为有些东西在Android环境中表现不出来。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，这里我们使用的是第二种创建方式创建的协程，我们运行一下代码（这里啰嗦一句，这个main函数就是kotlin的写法，对应了Java中的 <code>public static void main(String[] args)</code> ），可以观察到先是打印了launch，过了一秒又打印了kotlin coroutine run。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main] launch</span><br><span class="line">[main] kotlin coroutine run</span><br></pre></td></tr></table></figure>

<p>我们先看<code>GlobalScope</code>的定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope</span><br></pre></td></tr></table></figure>

<p>我们发现<code>GlobalScope</code>其实是继承自<code>CoroutineScope</code>的一个对象，是由系统提供的一种默认实现。<code>delay()</code>是一个挂起函数，和<code>Thread.sleep()</code>作用有些相似。上面这个示例理解起来也不困难。我们现在把这段代码修改一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再次运行代码看看打印了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] launch</span><br></pre></td></tr></table></figure>

<p>你会发现只打印了launch，这是为什么呢？我们上面说了，通过<code>GlobalScope</code>创建的协程和应用生命周期一致。这里的<code>main</code>函数执行完毕，也就意味着生命结束了。自然也就打印不了kotlin coroutine run。</p>
<p>　　刚才我们是通过<code>Thread.sleep()</code>去阻塞线程等待协程完成，这里我们换成协程又该怎么去阻塞线程呢？刚好<code>runBlocking&#123;&#125;</code>会阻塞线程，那么我们就可以通过<code>runBlocking</code> + <code>delay()</code>的方式去实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    runBlocking &#123; delay(<span class="number">2000</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们能实现相同的效果，但是不推荐。同样的是如果<code>runBlocking</code>中挂起时间过短的话，依然不会打印kotlin coroutine run。</p>
<p>　　上面的示例中是因为我们知道协程运行所需要的时间，我们可以等待对应的时间让协程任务得以完成，但在实际开发的过程中我们并不知道<code>launch</code>运行需要多少时间，但是又不能无限制的等待下去。为了实现这点，我们可以利用<code>launch</code>方法返回的<code>Job</code>对象来实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job: Job = GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        job.join()</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>join()</code>函数是一个挂起函数，会挂起当前协程，等到job执行完毕才恢复执行。输出结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main] launch</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] kotlin coroutine run</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p>　　在kotlin协程中，<code>suspend</code>是最最核心的关键字。被<code>suspend</code>修饰的函数就是挂起函数，<strong>它只能在协程或者另一个挂起函数中被调用</strong>。每当协程运行到挂起函数时会挂起当前协程。只有当挂起结束后才会回复协程并继续向下执行。这也是上一个的示例中，为什么会最后打印end。</p>
<p>　　协程挂起的对象到底是什么？是挂起线程还是别的什么？既然叫挂起函数，是不是被挂起的就是函数呢？其实都不正确，<strong>挂起的对象是协程</strong>。我们用协程构建器（诸如<code>launch</code>，<code>async</code>等）构建协程时，闭包代码块就是我们挂起的对象。当这个闭包执行到某一个<code>suspend</code>函数时，这个协程就会被挂起。</p>
<p>　　那此时又是从哪里挂起？<strong>从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离</strong>。注意，不是这个协程停下来了！是脱离，当前线程不再管这个协程要去做什么了。这个时候线程就空闲下来了，可以去执行别的任务，或者被回收掉。当协程恢复执行的时候会根据<code>CoroutineDispatcher</code>为它分配一个线程。这也就可能导致协程在挂起前后会在不同的线程上执行。</p>
<p>　　这里建议稍微停下来，思考理解一下。理解完了看下面这个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;111 start&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;111 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;222 start&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;222 end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行以后可以很清晰的看到协程在调用<code>delay()</code>前后的线程不一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] 111 start</span><br><span class="line">[DefaultDispatcher-worker-1] 222 start</span><br><span class="line">[DefaultDispatcher-worker-2] 111 end</span><br><span class="line">[DefaultDispatcher-worker-4] 222 end</span><br></pre></td></tr></table></figure>

<h3 id="协程使用"><a href="#协程使用" class="headerlink" title="协程使用"></a>协程使用</h3><p>　　虽然我们上面已经使用了<code>launch</code>函数，这里也还是贴一下<code>launch</code>函数的定义，方便理解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Job</span><br></pre></td></tr></table></figure>

<h4 id="创建协程作用域"><a href="#创建协程作用域" class="headerlink" title="创建协程作用域"></a>创建协程作用域</h4><p>　　协程必须运行在协程作用域，即<code>CoroutineScope</code>之上，我们看看它的定义，它有且仅有一个成员属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在非协程环境中，通过普通方法创建协程作用域，就像下面两种方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = Job()</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Creates the main CoroutineScope for UI components.</span></span><br><span class="line">    <span class="comment">// 就是推荐在Activity等中使用</span></span><br><span class="line">    <span class="keyword">val</span> scope = MainScope()</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>CoroutineScope()</code>和<code>MainScope()</code>方法比较特别，它不是以小驼峰的命名规则去命名的，与kotlin的方法定义要求不一样，这里更像是去创建一个类的实例对象。如果看过<code>Compose</code>相关代码，应该知道这是故意为之。这两种方式都是比较常见的使用方式。</p>
<p>　　我们也可以在协程环境中通过调用<code>coroutineScope()</code>函数创建，这是一个<strong>挂起函数</strong>。它会创建一个新的协程作用域，但是它不会去启动一个新的协程。并且它也会等待所有启动的子协程全部完成后自身才会完成。它和<code>runBlocking()</code>之间最大的区别就是：前者在等待所有子协程完成其任务时不会阻塞当前线程。先看一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;job1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;out 111&quot;</span>)</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            log(<span class="string">&quot;job2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">10000</span>)</span><br><span class="line">        log(<span class="string">&quot;coroutineScope&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;out 222&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先说这个示例执行的结果是一定的，这个示例的核心点在于<code>coroutineScope</code>是一个挂起函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:43:18.233 [main] out 111</span><br><span class="line">18:43:19.240 [main] job1</span><br><span class="line">18:43:20.239 [main] job2</span><br><span class="line">18:43:28.238 [main] coroutineScope</span><br><span class="line">18:43:28.240 [main] out 222</span><br></pre></td></tr></table></figure>

<p>我们刚才说了<code>coroutineScope</code>不会阻塞当前线程，但是现在<code>out 222</code>又在最后输出。如果你觉得<code>out 222</code>不应该在最后打印，说明还是没有完全理解协程挂起，这里本身也是一个比较难以理解的点。</p>
<p>　　分析这个原因呢？我们可以查看<code>runBlocking</code>的定义。它就是一个普通方法，调用它的线程会一直位于该函数之中，直到协程全部执行完毕。而<code>coroutineScope</code>是一个挂起函数。也就是说，如果其中的协程挂起，那么<code>coroutineScope</code>也会挂起。这样创建<code>coroutineScope</code>的外层函数就可以继续在同一线程中执行了。该线程会逃离<code>coroutineScope</code>之外，并且可以做其他的事情。</p>
<p>　　为什么要这样设计？答案无非就是进行符合结构化并发的并行分解，即将长耗时任务拆分为并发的多个短耗时任务，并等待所有并发任务完成后再返回。</p>
<h4 id="协程取消"><a href="#协程取消" class="headerlink" title="协程取消"></a>协程取消</h4><p>　　协程取消是一个非常常见的场景，我们可以通过<code>Job.cancel()</code>去取消协程。如果你只是想取消协程，这一句话就已经差不多够使用了，但是我们要了解到它更具体的原理。</p>
<p>　　协程同线程一样，也有自己的转换逻辑和生命周期：</p>
<img src="https://s2.loli.net/2023/03/12/CdcirDmwzO1ZoMT.png" alt="Coroutine_life" style="zoom:70%;" />

<p>转换逻辑如下：</p>
<img src="https://s2.loli.net/2023/03/12/6TwmNbu3MCEdfYI.png" alt="Coroutine_covert" style="zoom:100%;" />

<p>我们先举个小栗子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    log(<span class="string">&quot;start cancel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.join()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    </span><br><span class="line">    log(<span class="string">&quot;end cancel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式可以任意选择一种方式去取消，一个因为协程取消本身是一个过程，所以需要调用<code>jion()</code>等待协程取消完成。我们可以观察到日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i am 0</span><br><span class="line">[DefaultDispatcher-worker-1] i am 1</span><br><span class="line">[DefaultDispatcher-worker-1] i am 2</span><br><span class="line">[DefaultDispatcher-worker-1] start cancel</span><br><span class="line">[DefaultDispatcher-worker-1] end cancel</span><br></pre></td></tr></table></figure>

<p>这两种方式的区别在于方式1在调用<code>cancel()</code>时可以额外传递一个<code>CancellationException</code>对象。为什么传递的对象是<code>Exception</code>对象呢？我们再看一段代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                log(e.javaClass.simpleName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    log(<span class="string">&quot;start cancel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    </span><br><span class="line">    log(<span class="string">&quot;end cancel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行就会发现输出的结果很神奇，我们调用了<code>cancelAndJoin()</code>后，协程并没有按照预想去关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-2] i am 0</span><br><span class="line">[DefaultDispatcher-worker-2] i am 1</span><br><span class="line">[DefaultDispatcher-worker-2] i am 2</span><br><span class="line">[DefaultDispatcher-worker-2] start cancel</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 3</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 4</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 5</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 6</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 7</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 8</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] i am 9</span><br><span class="line">[DefaultDispatcher-worker-1] JobCancellationException</span><br><span class="line">[DefaultDispatcher-worker-1] end cancel</span><br></pre></td></tr></table></figure>

<p>为什么产生这种现象呢？这个段代码唯一的区别是在循环体中我用<code>try-catch</code>将<code>delay()</code>进行包裹，并将异常进行捕获，观看结果可以看到我捕获了一个异常，也正因为我们将这个异常进行捕获了，所以协程体依然会运行下去。也就是说协程的<strong>停止实际上是通过抛出特别的异常</strong>（<code>JobCancellationException</code>）来进行的，也就是说如果协程体的代码不依赖协程的cancel状态（即没有报错），则协程的取消对协程体的执行一般没什么影响。</p>
<p>　　既然我们已然知道协程是通过抛出异常来进行终止的。那如果协程正在执行一些IO操作，在取消时我们去回收释放这部分资源自然而然的就能想到使用<code>try-finally</code>这种结构去实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">10</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    log(<span class="string">&quot;start cancel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    </span><br><span class="line">    log(<span class="string">&quot;end cancel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i am 0</span><br><span class="line">[DefaultDispatcher-worker-1] i am 1</span><br><span class="line">[DefaultDispatcher-worker-1] i am 2</span><br><span class="line">[DefaultDispatcher-worker-1] start cancel</span><br><span class="line">[DefaultDispatcher-worker-2] finally is run</span><br><span class="line">[DefaultDispatcher-worker-2] end cancel</span><br></pre></td></tr></table></figure>

<p>　　在<code>kotlinx.coroutines</code>包下的所有挂起函数都是可以被取消的。他们会检查协程的取消状态，当取消协程时会抛出<code>CancellationException</code>异常。但是<strong>如果一个协程正处于某个计算过程当中，并且没有检查取消状态，那么它就是无法被取消的</strong>。我们还是通过示例来分析：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> nextTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 会在CPU上空转很多次</span></span><br><span class="line">                <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">                <span class="keyword">if</span> (now &gt;= nextTime) &#123;</span><br><span class="line">                    log(<span class="string">&quot;i is <span class="subst">$&#123;i++&#125;</span>&quot;</span>)</span><br><span class="line">                    nextTime += <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">450</span>)</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里示例代码稍微有点长，通过观察日志，我们可以发现协程并没有和我们预想的一样，在我们调用<code>cancelAndJoin()</code>之后，协程并没有停止运行，而是一直运行到计算结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i is 0</span><br><span class="line">[DefaultDispatcher-worker-1] i is 1</span><br><span class="line">[DefaultDispatcher-worker-1] i is 2</span><br><span class="line">[main] start</span><br><span class="line">[DefaultDispatcher-worker-1] i is 3</span><br><span class="line">[DefaultDispatcher-worker-1] i is 4</span><br><span class="line">[DefaultDispatcher-worker-1] finally is run</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>我们现在有两种方式可以让计算代码变的是可取消的。</p>
<ul>
<li>周期性的调用一个挂起函数，该挂起函数会检查取消状态。比如<code>yield()</code>，这里不演示了。</li>
<li>显示的检查其取消状态</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> nextTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive) &#123;</span><br><span class="line">                <span class="comment">// 会在CPU上空转很多次</span></span><br><span class="line">                <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">                <span class="keyword">if</span> (now &gt;= nextTime) &#123;</span><br><span class="line">                    log(<span class="string">&quot;i is <span class="subst">$&#123;i++&#125;</span>&quot;</span>)</span><br><span class="line">                    nextTime += <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">450</span>)</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>isActive</code>。它是协程的一个扩展属性。其定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true when the current Job is still active (has not completed and was not cancelled yet).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> CoroutineScope.isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = coroutineContext[Job]?.isActive ?: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>我们再次运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i is 0</span><br><span class="line">[DefaultDispatcher-worker-1] i is 1</span><br><span class="line">[DefaultDispatcher-worker-1] i is 2</span><br><span class="line">[main] start</span><br><span class="line">[DefaultDispatcher-worker-1] finally is run</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>现在我们已经可以完全的去取消一个协程，在实际开发中，我们会在<code>finally</code>块中去关闭一些网络连接，或者关闭文件IO等。这通常来说都不是什么问题，并且这些都不会涉及到挂起函数。但是在一些极端情况下，我们不得不去调用挂起函数，但是<code>finally</code>代码块本身就意味着，协程即将结束，只是做最后的收尾工作。我们先看示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">10</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;finally is start&quot;</span>)</span><br><span class="line">            delay(<span class="number">200</span>)</span><br><span class="line">            log(<span class="string">&quot;finally is end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] i am 0</span><br><span class="line">[main] i am 1</span><br><span class="line">[main] i am 2</span><br><span class="line">[main] finally is start</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>我们可以观察到<code>finally is end</code>并没有打印出来，这里可以思考一下为什么没有打印出来？如果思考不出来可以用<code>try-catch</code>去包裹<code>delay(200)</code>试试。</p>
<p>我直接说解决方案，可以将代码放置到<code>withContext(NonCancellable)&#123;&#125;</code>中去，在这种结构中，我们实际使用了<code>withContext()</code>函数和<code>NonCancellable</code>上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">10</span>) &#123;</span><br><span class="line">                log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                log(<span class="string">&quot;finally is start&quot;</span>)</span><br><span class="line">                delay(<span class="number">200</span>)</span><br><span class="line">                log(<span class="string">&quot;finally is end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">250</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[main] i am 0</span><br><span class="line">[main] i am 1</span><br><span class="line">[main] i am 2</span><br><span class="line">[main] finally is start</span><br><span class="line">[main] finally is end</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>这里的<code>withContext()</code>是一个挂起函数，它<strong>不会创建新的协程</strong>，只可能会导致线程的切换。它会在指定的协程上运行挂起代码块。并且挂起函数直至代码块运行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * A non-cancelable job that is always [active][Job.isActive].</span><br><span class="line"> * It is designed for [withContext] function to prevent cancellation</span><br><span class="line"> * of code blocks that need to be executed without cancellation.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public object NonCancellable : AbstractCoroutineContextElement(Job), Job</span><br></pre></td></tr></table></figure>

<p>大体意思是：始终处于活动状态的不可取消<code>Job</code>。它是为<code>withContext</code>功能设计的，以防止取消需要执行而不取消的代码块。这就是一种固定写法，就不赘述了。</p>
<h4 id="协程超时"><a href="#协程超时" class="headerlink" title="协程超时"></a>协程超时</h4><p>　　协程提供了两个超时的挂起函数分别是<code>withTimeout()</code>和<code>withTimeoutOrNull()</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    withTimeout(<span class="number">1900</span>) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">400</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个输出结果应该是显而易见的。这两个函数都是可以有返回结果的。我们现在在函数里面添加一个返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeout&lt;String&gt;(<span class="number">1900</span>) &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            log(<span class="string">&quot;i am <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">400</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;result&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;result = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>削微的运行一下下就可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] i am 0</span><br><span class="line">[DefaultDispatcher-worker-1] i am 1</span><br><span class="line">[DefaultDispatcher-worker-1] i am 2</span><br><span class="line">[DefaultDispatcher-worker-1] i am 3</span><br><span class="line">[DefaultDispatcher-worker-1] i am 4</span><br></pre></td></tr></table></figure>

<p>超时其实还是走的取消机制，输出的结果也比较好理解，如果还是不理解就用<code>try-catch</code>去包裹超时函数运行。<code>withTimeoutOrNull()</code>其实就是帮我们捕获了异常，然后在超时后返回一个<code>null</code>给我们。代码就不演示了。</p>
<h3 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h3><h4 id="挂起函数的组合"><a href="#挂起函数的组合" class="headerlink" title="挂起函数的组合"></a>挂起函数的组合</h4><p>　　前面我们说挂起函数只能在协程或者另一个挂起函数中被调用。我们现在可以来组合使用，先定义两个测试方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunA</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;suspend fun A start&quot;</span>)</span><br><span class="line">    delay(<span class="number">200</span>)</span><br><span class="line">    log(<span class="string">&quot;suspend fun A end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunB</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;suspend fun B start&quot;</span>)</span><br><span class="line">    delay(<span class="number">300</span>)</span><br><span class="line">    log(<span class="string">&quot;suspend fun B end&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在需要知道两个方法的结果值的和。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> a = suspendFunA()</span><br><span class="line">        <span class="keyword">val</span> b = suspendFunB()</span><br><span class="line">        log(<span class="string">&quot;<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22:02:21.508 [DefaultDispatcher-worker-1] suspend fun A start</span><br><span class="line">22:02:21.714 [DefaultDispatcher-worker-2] suspend fun A end</span><br><span class="line">22:02:21.716 [DefaultDispatcher-worker-2] suspend fun B start</span><br><span class="line">22:02:22.020 [DefaultDispatcher-worker-2] suspend fun B end</span><br><span class="line">22:02:22.021 [DefaultDispatcher-worker-2] 200 + 300 &#x3D; 500</span><br><span class="line">22:02:22.025 [DefaultDispatcher-worker-2] time &#x3D; 513</span><br></pre></td></tr></table></figure>

<p>这里的A和B都是挂起函数，会直接挂起当前协程。这并没有实现我们想要的并发。这里我们就会使用到一个新的协程构建器<code>async</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Deferred&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>　　从概念上来说，<code>async</code>和<code>launch</code>一样，它会开启一个单独的协程，可以与协程并发工作。区别在于后者返回的是一个<code>Job</code>对象，但是<code>Job</code>不会持有任何的结果值。而前者返回的是一个<code>Deferred</code>对象，该对象是<code>Job</code>的一个子类对象，并且它额外实现了<code>await()</code>用于获取结果，需要注意的是<code>await()</code>是一个挂起函数。既然是<code>Job</code>的子类，那么<code>Job</code>有的功能，它也全都有。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> a = async &#123; suspendFunA() &#125;</span><br><span class="line">        <span class="keyword">val</span> b = async &#123; suspendFunB() &#125;</span><br><span class="line">        log(<span class="string">&quot;<span class="subst">$&#123;a.await()&#125;</span> + <span class="subst">$&#123;b.await()&#125;</span> = <span class="subst">$&#123;a.await() + b.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">22:20:54.846 [DefaultDispatcher-worker-1] start</span><br><span class="line">22:20:54.847 [DefaultDispatcher-worker-2] suspend fun A start</span><br><span class="line">22:20:54.848 [DefaultDispatcher-worker-2] suspend fun B start</span><br><span class="line">22:20:55.049 [DefaultDispatcher-worker-1] suspend fun A end</span><br><span class="line">22:20:55.149 [DefaultDispatcher-worker-1] suspend fun B end</span><br><span class="line">22:20:55.150 [DefaultDispatcher-worker-1] 200 + 300 &#x3D; 500</span><br><span class="line">22:20:55.150 [DefaultDispatcher-worker-1] time &#x3D; 304</span><br></pre></td></tr></table></figure>

<p>千万不能写成下面这样，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> a = async &#123; suspendFunA() &#125;.await()</span><br><span class="line">        <span class="keyword">val</span> b = async &#123; suspendFunB() &#125;.await()</span><br><span class="line">        log(<span class="string">&quot;<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>b</code>需要依赖<code>a</code>的结果，我们不得不在<code>b</code>之前去等待结果。应该考虑使用<code>withContext()</code>来编写逻辑。</p>
<h4 id="父子协程"><a href="#父子协程" class="headerlink" title="父子协程"></a>父子协程</h4><p>　　当一个协程是通过另一个协程的协程作用域(<code>CoroutineScope</code>)来启动的，那么这个协程就会通过<code>CoroutineScope.coroutineContext</code>来继承其上下文信息，同时新的协程会成为外部协程的一个孩子，当父协程被取消时，该父协程会通过递归的方式一并取消子协程的执行。举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    <span class="keyword">val</span> jobParent = launch &#123;</span><br><span class="line">        log(<span class="string">&quot;run in parent&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> jobChild = launch &#123;</span><br><span class="line">            log(<span class="string">&quot;run in child&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            log(<span class="string">&quot;i am child&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;run in GlobalScope&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">            log(<span class="string">&quot;I don&#x27;t have a father&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">300</span>)</span><br><span class="line">    log(<span class="string">&quot;jobParent is cancel&quot;</span>)</span><br><span class="line">    jobParent.cancelAndJoin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>jobChild</code>和<code>jobParent</code>就是父子关系，但是<code>job</code>和他们不存在父子关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-2] run in parent</span><br><span class="line">[DefaultDispatcher-worker-1] run in child</span><br><span class="line">[DefaultDispatcher-worker-3] run in GlobalScope</span><br><span class="line">[DefaultDispatcher-worker-3] jobParent is cancel</span><br><span class="line">[DefaultDispatcher-worker-2] I don&#39;t have a father</span><br></pre></td></tr></table></figure>

<h4 id="协程的完成"><a href="#协程的完成" class="headerlink" title="协程的完成"></a>协程的完成</h4><p>　　无论是使用的<code>launch</code>还是<code>runBlocking</code>它们都被称为协程构建器，它们有一个最重要的特点就是会先构建一个<code>CoroutineScope</code>的实例，并将它添加到代码块的作用域之内，而不用显示将它们<code>join()</code>在一起。这是因为<strong>外部协程会等待该作用域的所有启动的协程全部执行完毕后才会完成</strong>。我们先看一个代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的示例，用于对比</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> job: Job = GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        job.join()</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[main] launch</span><br><span class="line">[main] kotlin coroutine run</span><br></pre></td></tr></table></figure>

<p>我们对比两个示例，会发现我们没有调用<code>join()</code>函数，但是依然打印了kotlin coroutine run。我们修改一下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;kotlin coroutine run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们思考一下，这段代码会打印什么？</p>
<p>如果你的分析结果和打印结果不一致，说明还是我没有讲清楚，可以按照示例重新在梳理一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] launch</span><br></pre></td></tr></table></figure>

<h4 id="父子协程的异常和取消"><a href="#父子协程的异常和取消" class="headerlink" title="父子协程的异常和取消"></a>父子协程的异常和取消</h4><p>　　当子协程出现异常而没有处理时，错误就会向上传递给父协程，取消父协程。这个时候这个父协程的所有子协程都会被一并取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> value1 = async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="number">90000</span>)</span><br><span class="line">            <span class="number">100</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;value1 finally is run&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value2 = async&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log(<span class="string">&quot;result = <span class="subst">$&#123;value1.await() + value2.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] start</span><br><span class="line">[DefaultDispatcher-worker-3] value1 finally is run</span><br><span class="line">E&#x2F;AndroidRuntime: FATAL EXCEPTION: DefaultDispatcher-worker-1</span><br><span class="line">    Process: space.lianxin.coroutine, PID: 12512</span><br><span class="line">    java.lang.RuntimeException</span><br></pre></td></tr></table></figure>

<p>在一些特定的情况下，我们需要子协程出现异常时，父协程不退出。我们可以使用<strong>监督</strong>的来解决。使用方式是将<code>SupervisorJob</code>在协程启动时当上下文元素传入。</p>
<h4 id="协程的调试"><a href="#协程的调试" class="headerlink" title="协程的调试"></a>协程的调试</h4><p>现在的IDE基本都能够做到和线程一样，在IDE中直接通过debug窗口调试，并且调试方式是差不多的。这种调试方式我就不讲解了，我们看如何通过日志进行调试。</p>
<ul>
<li><p>单元测试</p>
<p>通过添加Jvm参数进行调试。Ddit Configurations -&gt; VM options -&gt; 如下参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dkotlinx.coroutines.debug</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2023/03/12/xZuvq9KIS7BCUAd.png" alt="Coroutine_ide_debug" style="zoom:100%;" />
</li>
<li><p>App项目</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        System.setProperty(<span class="string">&quot;kotlinx.coroutines.debug&quot;</span>, <span class="string">&quot;on&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这个时候我们运行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;log in debug&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1 @coroutine#2] log in debug</span><br></pre></td></tr></table></figure>

<p>我们现在获取的线程名称就变成了<code>线程名称 @协程名称#协程ID</code>的格式。这些名字和ID都是可以进行修改的，后续会讲解到。</p>
<h3 id="协程的启动模式"><a href="#协程的启动模式" class="headerlink" title="协程的启动模式"></a>协程的启动模式</h3><p>　　观察协程构建器，无论是<code>launch</code>还是<code>async</code>除了协程闭包之外，还需要额外的两个参数，分别是<code>CoroutineContext</code>和<code>CoroutineStart</code>对象，这个<code>CoroutineStart</code>是一个枚举对象，我们先从简单的入手。</p>
<ul>
<li><p><code>DEFAULT</code></p>
<p>　　在我们调用协程构建器的时候默认传入的就是<code>DEFAULT</code>。当我们使用这个值作为协程的启动模式时，会根据当前的协程上下文<strong>立即开始调度执行</strong>。</p>
</li>
<li><p><code>LAZY</code></p>
<p>　　这个就见名知意了，我们在一些特定的情况下，其实并不希望协程被创建后就立即执行，而是在一个合适的时机开始执行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> a = async(start = CoroutineStart.LAZY) &#123; suspendFunA() &#125;</span><br><span class="line">        <span class="keyword">val</span> b = async(start = CoroutineStart.LAZY) &#123; suspendFunB() &#125;</span><br><span class="line"></span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">        a.start()</span><br><span class="line">        b.start()</span><br><span class="line"></span><br><span class="line">        log(<span class="string">&quot;<span class="subst">$&#123;a.await()&#125;</span> + <span class="subst">$&#123;b.await()&#125;</span> = <span class="subst">$&#123;a.await() + b.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;time = <span class="variable">$time</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">21:18:01.949 [DefaultDispatcher-worker-1] start</span><br><span class="line">21:18:02.258 [DefaultDispatcher-worker-2] suspend fun A start</span><br><span class="line">21:18:02.260 [DefaultDispatcher-worker-2] suspend fun B start</span><br><span class="line">21:18:02.463 [DefaultDispatcher-worker-3] suspend fun A end</span><br><span class="line">21:18:02.562 [DefaultDispatcher-worker-3] suspend fun B end</span><br><span class="line">21:18:02.564 [DefaultDispatcher-worker-1] 200 + 300 &#x3D; 500</span><br><span class="line">21:18:02.564 [DefaultDispatcher-worker-1] time &#x3D; 615</span><br></pre></td></tr></table></figure>

<p>当我们使用<code>LAZY</code>去创建一个协程的时候，协程并不会立即执行，而是等到我们调用<code>start()</code>或者<code>await()</code>方法之后才会开始执行，当然你也可以使用<code>join</code>方法。通过上面的示例也可以看出来，这里可以思考一下换成使用<code>a.await()</code>让协程开始执行会出现什么样的结果。</p>
</li>
<li><p><code>ATOMIC</code></p>
<p>　　到目前为止，这都只是一个试验性质的Api。它会根据协程的上下文原子地(即，以一种不可取消的方式)调度其执行。这类似于<code>DEFAULT</code>，但是协程在开始执行之前不能被取消。因为其还处在试验阶段，我也没有具体的去研究，就不介绍了。</p>
</li>
<li><p><code>UNDISPATCHED</code></p>
<p>　　它的作用是<strong>立即在父协程的上下文中执行代码</strong>，直到遇到第一个挂起函数。在第一个挂起函数之后，代码就会由当前协程的调度器调度执行。废话少说，直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = GlobalScope.launch &#123;</span><br><span class="line">    log(<span class="string">&quot;parent start&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">        log(<span class="string">&quot;run in parent&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">&quot;run in child Dispatchers&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">&quot;run in child Dispatchers again&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;parent end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">21:51:04.151 [DefaultDispatcher-worker-1] parent start</span><br><span class="line">21:51:04.152 [DefaultDispatcher-worker-1] run in parent</span><br><span class="line">21:51:04.152 [DefaultDispatcher-worker-1] parent end</span><br><span class="line">21:51:04.253 [main] run in child Dispatchers</span><br><span class="line">21:51:04.356 [main] run in child Dispatchers again</span><br></pre></td></tr></table></figure>

<p>观察输出，我们可以看到，被创建的协程是立即执行的，并且和父协程运行在同一个线程中。和我们所期待的结果是一致的。对于这段代码不管运行多少次，结果总是确定的。</p>
</li>
</ul>
<h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>　　协程总是会在某个协程上下文（<code>CoroutineContext</code>）中执行，协程上下文本质上是各种元素所构成的一个集合，主要的元素就包括协程的<code>Job</code>以及<code>CoroutineDispatcher</code>。我们可以先看看源码中的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Persistent context for the coroutine. It is an indexed set of [Element] instances.</span></span><br><span class="line"><span class="comment"> * An indexed set is a mix between a set and a map.</span></span><br><span class="line"><span class="comment"> * Every element in this set has a unique [Key].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E : Element</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　从定义来看，它拥有的<code>Element</code>是任意多个的，但是对于相同Key的元素只会有一个。前面我们说到的协程的分发器，其实就是协程上下文的一个子类。协程为我们内置了很多已经实现的协程上下文。</p>
<h4 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h4><p>　　这是一个我们使用非常频繁的协程上下文对象，他的继承自<code>AbstractCoroutineContextElement</code>。<code>AbstractCoroutineContextElement</code>是<code>Element</code>的一个子类对象。其实我们阅读源码的时候，会发现大部分的协程上下文都是<code>Element</code>的子类。只有少数如<code>EmptyCoroutineContext</code>和<del><code>TestCoroutineContext</code></del>才是直接继承自<code>CoroutineContext</code>的。</p>
<p>　　回到我们的协程分发器，<code>CoroutineDispatcher</code>他是一个抽象类并且实现了<code>ContinuationInterceptor</code>接口，所有的协程分发器，必须是它的一个子类。它的主要作用就是确定当前协程由那个线程或者线程池来执行。</p>
<h5 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h5><p>　　这是一个协程分发器内置对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        DefaultExecutor.shutdown()</span><br><span class="line">        DefaultScheduler.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们上面已经使用过很多次这个协程分发器了，我们看看具体的含义。</p>
<ul>
<li><p>Dispatcher.Default</p>
<p>首先说，它被用于<strong>计算密集型</strong>任务。它是由Jvm共享线程池支持。默认情况下最大的并行级别为CPU的核心数，但是不会低于2。可以通过<code>limitedParallelism()</code>进行修改。如果从最外层的协程开始都没有指定任何的分发器和拦截器，那么所有标准协程构建器如<code>launch</code>就会使用它进行创建协程。</p>
</li>
<li><p>Dispatcher.Main</p>
<p>这个<strong>只能用于UI线程</strong>，并且需要使用引入对于的平台库才能使用。</p>
</li>
<li><p>Dispatcher.IO</p>
<p>它被用于<strong>IO密集型</strong>任务，也就是阻塞情况偏多的情况，如文件读写，网络请求等。它<code>Default</code>共享线程池，不过对IO进行了优化。</p>
</li>
<li><p>Dispatcher.Unconfined</p>
<p>前面三个都很好理解，使用也很多。这是一个非常特殊的分发器，它是<strong>不加任何限制的去执行</strong>我们的协程代码。我们所指定的代码到底是由哪一个线程或者线程池来执行是不确定的，需要根据程序实际执行的情况去确定。</p>
</li>
</ul>
<p>Dispatcher.Unconfined会在父协程的分发器上执行代码，但是仅仅持续到第一个挂起点。当挂起结束恢复执行时，会在挂起函数的线程执行后续代码直到再次遇到挂起函数。但如果之前的线程已经取消或者死亡，则会自己开启一个新的线程来执行。</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;active&quot;</span>)</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Main) &#123; log(<span class="string">&quot;do something in main&quot;</span>) &#125;</span><br><span class="line">        log(<span class="string">&quot;after main&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123; log(<span class="string">&quot;do something in IO&quot;</span>) &#125;</span><br><span class="line">        log(<span class="string">&quot;after IO&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Default) &#123; log(<span class="string">&quot;do something in Default&quot;</span>) &#125;</span><br><span class="line">        log(<span class="string">&quot;after Default&quot;</span>)</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    log(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们可以看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1] active</span><br><span class="line">[DefaultDispatcher-worker-1] start</span><br><span class="line">[main] do something in main</span><br><span class="line">[main] after main</span><br><span class="line">[DefaultDispatcher-worker-1] do something in IO</span><br><span class="line">[DefaultDispatcher-worker-1] after IO</span><br><span class="line">[DefaultDispatcher-worker-3] do something in Default</span><br><span class="line">[DefaultDispatcher-worker-3] after Default</span><br><span class="line">[DefaultDispatcher-worker-3] finish</span><br><span class="line">[main] end</span><br></pre></td></tr></table></figure>

<p>这是一个极少使用的协程分发器，在我们的实际开发过程中几乎不会使用到它。它避免调度程序中启动的嵌套协程形成事件循环以至堆栈溢出。</p>
<h5 id="asCoroutineDispatcher"><a href="#asCoroutineDispatcher" class="headerlink" title="asCoroutineDispatcher"></a>asCoroutineDispatcher</h5><p>　　除去默认提供的一些分发器，我们还可以自行实现协程的分发器，或者使用java线程池来分派协程任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Converts an instance of ExecutorService to an implementation of ExecutorCoroutineDispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ExecutorService.<span class="title">asCoroutineDispatcher</span><span class="params">()</span></span>: ExecutorCoroutineDispatcher =</span><br><span class="line">    ExecutorCoroutineDispatcherImpl(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出<code>asCoroutineDispatcher()</code>本身是一个扩展方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    <span class="keyword">val</span> singleThread = Executors.newSingleThreadExecutor()</span><br><span class="line">    launch(singleThread.asCoroutineDispatcher()) &#123;</span><br><span class="line">        log(<span class="string">&quot;i am run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，确实能得到预期的结果。不过这种写法多来点你就会发现你创建了非常多的线程池，并且每个任务还都在运行中。这是因为我们并没有关闭线程池。解决办法无外乎就是两种，第一种：声明成为全局线程池，提供给别处使用。第二种方式就是在协程最后一行去调用线程池的<code>shutdown()</code>方法。</p>
<h5 id="newSingleThreadContext"><a href="#newSingleThreadContext" class="headerlink" title="newSingleThreadContext"></a>newSingleThreadContext</h5><p>　　创建一个单线程的协程分发器。</p>
<h5 id="newFixedThreadPoolContext"><a href="#newFixedThreadPoolContext" class="headerlink" title="newFixedThreadPoolContext"></a>newFixedThreadPoolContext</h5><p>　　这个就是与<code>newSingleThreadContext()</code>对应的了。</p>
<h4 id="CoroutineExceptionHandler"><a href="#CoroutineExceptionHandler" class="headerlink" title="CoroutineExceptionHandler"></a>CoroutineExceptionHandler</h4><p>　　用于处理协程异常情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">    launch(CoroutineExceptionHandler &#123; context, throwable -&gt;</span><br><span class="line">        <span class="comment">// on error run</span></span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="asContextElement"><a href="#asContextElement" class="headerlink" title="asContextElement"></a>asContextElement</h4><p>　　它的作用是将<code>ThreadLocal</code>包装为<code>ThreadContextElement</code>。为协程<strong>维护指定ThreadLocal的给定值</strong>，而不管它在哪个线程上恢复。他更像是一个协程的本地变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> local = ThreadLocal&lt;String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Dispatchers.Main).launch &#123;</span><br><span class="line">    local.<span class="keyword">set</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    log(<span class="string">&quot;start local = <span class="subst">$&#123;local.get()&#125;</span>&quot;</span>)</span><br><span class="line">    launch(Dispatchers.IO + local.asContextElement(<span class="string">&quot;456&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;launch start local = <span class="subst">$&#123;local.get()&#125;</span>&quot;</span>)</span><br><span class="line">        yield()</span><br><span class="line">        log(<span class="string">&quot;launch mid local = <span class="subst">$&#123;local.get()&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.Default) &#123;</span><br><span class="line">            log(<span class="string">&quot;launch end local = <span class="subst">$&#123;local.get()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.join()</span><br><span class="line">    log(<span class="string">&quot;end local = <span class="subst">$&#123;local.get()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] start local &#x3D; 123</span><br><span class="line">[DefaultDispatcher-worker-2] launch start local &#x3D; 456</span><br><span class="line">[DefaultDispatcher-worker-2] launch mid local &#x3D; 456</span><br><span class="line">[DefaultDispatcher-worker-3] launch end local &#x3D; 456</span><br><span class="line">[main] end local &#x3D; 123</span><br></pre></td></tr></table></figure>

<p>这里我们说过withContext不会创建新的协程，只会导致线程的切换。可以看到是我们预想的结果。如果我们把withContext中的分发器指定为main线程，会出现什么结果？或者将withContext替换为launch呢？这点结合协程的父子关系还是可以推断出是一样的结果。</p>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>先提出一个问题，我们如何通过正在执行的协程，获取当前协程的Job对象？协程Job是属于协程上下文的一部分，我们也说了协程上下文本身就是一个元素的集合。我们可以在协程的作用域获取到协程上下文，并且通过这个上下文获取到Job对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job: Job? = coroutineContext[Job]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>coroutineContext</code>是协程作用域的一个成员属性，我们可以拿到，<code>[]</code>是通过操作符重载get方法而来的。现在问题就在Job是怎么来的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [Job] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的协程上下文的定义也抄下来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E : Element</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里对于不怎么熟悉语法的人来说获取Job应该是<code>val job: Job? = coroutineContext[Job.Key]</code>才对啊？为什么<code>.Key</code>没有了。这里可能有点绕。仔细梳理一下还是比较容易理解的，问题就出在Job的伴生对象上。接口的伴生对象可以直接通过接口的名称获取，这是kotlin的一个语法糖。这个语法糖希望对你自己阅读源码有一定的帮助。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> job: Job? = coroutineContext[Job]</span><br><span class="line">        log(<span class="string">&quot;job = <span class="variable">$job</span>&quot;</span>)</span><br><span class="line">        job?.cancelAndJoin()</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-3] start</span><br><span class="line">[DefaultDispatcher-worker-3] job &#x3D; &quot;coroutine#3&quot;:StandaloneCoroutine&#123;Active&#125;@785e25f</span><br></pre></td></tr></table></figure>

<p>通过这个示例我们对协程上下文应该是更进一步的了解了。</p>
<h4 id="CoroutineName"><a href="#CoroutineName" class="headerlink" title="CoroutineName"></a>CoroutineName</h4><p>　　它也是一个协程上下文，就像线程可以被命名一样，<code>CoroutineName</code>用于给协程指定协程名称。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Job()).launch &#123;</span><br><span class="line">    launch(CoroutineName(<span class="string">&quot;myCoroutine&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-2 @myCoroutine#3] log</span><br></pre></td></tr></table></figure>

<h4 id="协程上下文的组合"><a href="#协程上下文的组合" class="headerlink" title="协程上下文的组合"></a>协程上下文的组合</h4><p>　　我们观察协程构建器，入参只要需要一个<code>CoroutineContext</code>对象，如果我们需要使用协程命名并且还要指定他的分发器应该怎么做？协程上下文重载了<code>+</code>操作符，我们可以通过<code>+</code>号来组合多个协程上下文。需要注意的是他是通过Key来覆盖的，也就是说同一类型的协程上下文只能有一个。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">    log(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    launch(Dispatchers.Main + CoroutineName(<span class="string">&quot;myCoroutine1&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;log1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Main + CoroutineName(<span class="string">&quot;myCoroutine2&quot;</span>) + Dispatchers.IO) &#123;</span><br><span class="line">        log(<span class="string">&quot;log2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1 @coroutine#2] log</span><br><span class="line">[main @myCoroutine1#3] log1</span><br><span class="line">[DefaultDispatcher-worker-3 @myCoroutine2#4] log2</span><br></pre></td></tr></table></figure>

<h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>协程作用域(<code>CoroutineScope</code>)，用于管理协程：</p>
<ul>
<li><p>管理启动协程的方式</p>
<p>它定义了<code>launch</code>、<code>async</code>、<code>withContext</code>等协程启动方法，并在这些方法内定义了启动子协程时上下文的继承方式。</p>
</li>
<li><p>管理协程生命周期</p>
<p>它定义了<code>cancel()</code>方法，用于取消当前作用域，同时取消作用域内所有协程。</p>
</li>
</ul>
<p>我们应该如何区分协程上下文和协程作用域呢？从类定义看，他们非常类似，最终目的都是管理协程，但正如Kotlin协程负责人Roman Elizarov在Coroutine Context and Scope中所说，二者的区别只在于使用目的的不同：<strong>作用域用于管理协程；而上下文只是一个记录协程运行环境的集合</strong>。他们的关系如下：</p>
<img src="https://s2.loli.net/2023/03/12/tBAThZaYOHymqof.png" alt="Coroutine_relation" style="zoom:100%;" />

<h3 id="约定和经验"><a href="#约定和经验" class="headerlink" title="约定和经验"></a>约定和经验</h3><h4 id="避免使用GlobalScope-launch"><a href="#避免使用GlobalScope-launch" class="headerlink" title="避免使用GlobalScope.launch"></a>避免使用GlobalScope.launch</h4><p>　　GlobalScope是实现了CoroutineScope的单例对象，含有一个空的上下文对象。这意味着它的生命周期与整个应用绑定，并且永远不会被主动取消，这是危险的。正确的做法是将自己的组件实现CoroutineScope，并在组件销毁时调用作用域的cancel()方法。实现方式多使用委托。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">         cancel() <span class="comment">// cancel is extension on CoroutineScope</span></span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vertx例子</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineVerticle</span> : <span class="type">Verticle</span>, <span class="type">CoroutineScope &#123;</span></span></span><br><span class="line">  <span class="comment">// 默认上下文使用context.dispatcher()</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext <span class="keyword">by</span> lazy &#123; context.dispatcher() &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="suspend和CoroutineScope扩展"><a href="#suspend和CoroutineScope扩展" class="headerlink" title="suspend和CoroutineScope扩展"></a>suspend和CoroutineScope扩展</h4><p>　　在Kotlin中，有两个约定俗成的东西：</p>
<ul>
<li>每一个仅被声明为<code>suspend</code>的方法。会等待其内部的逻辑全部完成之后再返回给调用者。</li>
<li>每一个被声明为<code>CoroutineScope</code>扩展方法的方法，都会立即返回，但是并发的执行扩展方法的内容。</li>
</ul>
<p>这两个是约定俗成的，这也是为什么在源码中，<code>launch</code>和<code>async</code>是扩展方法，而<code>runBlocking</code>和<code>withContext</code>却是<code>suspend</code>方法。如果一个方法定义成下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">myfun</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>它是suspend方法，同时也是CoroutineScope的扩展方法，调用者并不知道在方法内是否会启动新的协程，凭空给代码增加了复杂度，因此不推荐使用。suspend方法就应该在所有任务都完成后再返回。如果在suspend方法内部有需要并发执行的内容，那就应该等待他们都完成后再返回，此时可以使用<code>coroutineScope&#123;&#125;</code>，而不是在方法签名上加上CoroutineScope扩展。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">myfun</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span> = coroutineScope &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样才更加符合惯用法。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　本文详述了Kotlin协程的基本用法及重要组件的运行机制，对它们有了足够详细的了解和清晰的认识有助于我们写出正确的Kotlin协程代码。当然实际使用还需要根据具体情况选择恰当的API。虽然讲了这么多，但是异步流和通道这些都还没介绍到。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingyizhuyin@qq.com">恋心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lianxin.space/2023/03/12/Coroutine/">http://lianxin.space/2023/03/12/Coroutine/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lianxin.space" target="_blank">恋心</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5/">异步</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a><a class="post-meta__tags" href="/tags/%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/">结构化并发</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/Coroutine2/"><img class="prev-cover" src="https://s2.loli.net/2023/03/19/Zhlmq7gRPMs9v8H.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kotlin协程-Flow篇</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/08/Delegation/"><img class="next-cover" src="https://s2.loli.net/2023/02/08/UW97MndHp6ei3fF.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Kotlin中的委托</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/02/26/6htEVf4X7aIqLxk.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">恋心</div><div class="author-info__description">稳　稳　的　幸　福</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lianxin0119"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">让我们放弃前行的到底是「懦弱」还是「满足」？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.</span> <span class="toc-text">协程的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86"><span class="toc-number">4.</span> <span class="toc-text">初步认识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%AF%BC%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">依赖导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.3.</span> <span class="toc-text">第一个协程实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suspend"><span class="toc-number">5.</span> <span class="toc-text">suspend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">协程使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.1.</span> <span class="toc-text">创建协程作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="toc-number">6.2.</span> <span class="toc-text">协程取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%B6%85%E6%97%B6"><span class="toc-number">6.3.</span> <span class="toc-text">协程超时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">7.</span> <span class="toc-text">结构化并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">7.1.</span> <span class="toc-text">挂起函数的组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%8D%8F%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">父子协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%8C%E6%88%90"><span class="toc-number">7.3.</span> <span class="toc-text">协程的完成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%8F%96%E6%B6%88"><span class="toc-number">7.4.</span> <span class="toc-text">父子协程的异常和取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">7.5.</span> <span class="toc-text">协程的调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">协程的启动模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">9.</span> <span class="toc-text">协程上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CoroutineDispatcher"><span class="toc-number">9.1.</span> <span class="toc-text">CoroutineDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dispatcher"><span class="toc-number">9.1.1.</span> <span class="toc-text">Dispatcher</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asCoroutineDispatcher"><span class="toc-number">9.1.2.</span> <span class="toc-text">asCoroutineDispatcher</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newSingleThreadContext"><span class="toc-number">9.1.3.</span> <span class="toc-text">newSingleThreadContext</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newFixedThreadPoolContext"><span class="toc-number">9.1.4.</span> <span class="toc-text">newFixedThreadPoolContext</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CoroutineExceptionHandler"><span class="toc-number">9.2.</span> <span class="toc-text">CoroutineExceptionHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asContextElement"><span class="toc-number">9.3.</span> <span class="toc-text">asContextElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Job"><span class="toc-number">9.4.</span> <span class="toc-text">Job</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CoroutineName"><span class="toc-number">9.5.</span> <span class="toc-text">CoroutineName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">9.6.</span> <span class="toc-text">协程上下文的组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.</span> <span class="toc-text">协程作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A%E5%92%8C%E7%BB%8F%E9%AA%8C"><span class="toc-number">11.</span> <span class="toc-text">约定和经验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8GlobalScope-launch"><span class="toc-number">11.1.</span> <span class="toc-text">避免使用GlobalScope.launch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#suspend%E5%92%8CCoroutineScope%E6%89%A9%E5%B1%95"><span class="toc-number">11.2.</span> <span class="toc-text">suspend和CoroutineScope扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/23/Coroutine3/" title="Kotlin协程-热流篇"><img src="https://s2.loli.net/2023/06/24/LFk5x7nbzOcUMZB.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin协程-热流篇"/></a><div class="content"><a class="title" href="/2023/04/23/Coroutine3/" title="Kotlin协程-热流篇">Kotlin协程-热流篇</a><time datetime="2023-04-23T01:34:00.000Z" title="发表于 2023-04-23 09:34:00">2023-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/Coroutine2/" title="Kotlin协程-Flow篇"><img src="https://s2.loli.net/2023/03/19/Zhlmq7gRPMs9v8H.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin协程-Flow篇"/></a><div class="content"><a class="title" href="/2023/03/26/Coroutine2/" title="Kotlin协程-Flow篇">Kotlin协程-Flow篇</a><time datetime="2023-03-26T06:02:00.000Z" title="发表于 2023-03-26 14:02:00">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/12/Coroutine/" title="Kotlin协程-使用篇"><img src="https://s2.loli.net/2023/03/12/k9oRDIGfHK1cuse.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin协程-使用篇"/></a><div class="content"><a class="title" href="/2023/03/12/Coroutine/" title="Kotlin协程-使用篇">Kotlin协程-使用篇</a><time datetime="2023-03-12T08:14:00.000Z" title="发表于 2023-03-12 16:14:00">2023-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/Delegation/" title="Kotlin中的委托"><img src="https://s2.loli.net/2023/02/08/UW97MndHp6ei3fF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin中的委托"/></a><div class="content"><a class="title" href="/2023/02/08/Delegation/" title="Kotlin中的委托">Kotlin中的委托</a><time datetime="2023-02-08T10:46:00.000Z" title="发表于 2023-02-08 18:46:00">2023-02-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/03/12/k9oRDIGfHK1cuse.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 恋心</div><div class="footer_custom_text">逆水行舟 不进则退</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>