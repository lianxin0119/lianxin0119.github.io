<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Android存储 | 恋心</title><meta name="keywords" content="持久化,适配"><meta name="author" content="恋心,qingyizhuyin@qq.com"><meta name="copyright" content="恋心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="之前我们学习了使用数据库持久化存储数据，在android中还有许多其他的持久化存储数据的方式，比如使用SharedPreferences存储键值对数据等，今天我们将学习文件存储机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android存储">
<meta property="og:url" content="http://lianxin.space/2022/05/29/Storage/index.html">
<meta property="og:site_name" content="恋心">
<meta property="og:description" content="之前我们学习了使用数据库持久化存储数据，在android中还有许多其他的持久化存储数据的方式，比如使用SharedPreferences存储键值对数据等，今天我们将学习文件存储机制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/05/29/T9c6nAC2rbyLHx1.jpg">
<meta property="article:published_time" content="2022-05-29T01:44:00.000Z">
<meta property="article:modified_time" content="2022-08-16T13:10:34.546Z">
<meta property="article:author" content="恋心">
<meta property="article:tag" content="持久化">
<meta property="article:tag" content="适配">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/05/29/T9c6nAC2rbyLHx1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lianxin.space/2022/05/29/Storage/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android存储',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-16 21:10:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/02/26/6htEVf4X7aIqLxk.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/05/29/T9c6nAC2rbyLHx1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">恋心</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android存储</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-05-29T01:44:00.000Z" title="发表于 2022-05-29 09:44:00">2022-05-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　在android中存在多种持久化存储方式。各种存储方式的侧重点也不尽相同，都有各自优劣，根据自己的需要选择合适的存储方式对开发至关重要。本文主要学习android的文件存储，但是也会介绍到一些其他的存储方式。</p>
<ul>
<li><p>使用SharedPreferences保存一些键值对数据</p>
<p>通常用于去记录一些用户偏好，是否保存密码等等。推荐使用MMKV来替代SharedPreferences。</p>
</li>
<li><p>使用数据库去存储一些结构数据。</p>
<p>通常用于记录一些结构化的数据，比如用户收藏列表等等。</p>
</li>
<li><p>网络存储</p>
</li>
<li><p>文件存储</p>
<p>文件存储是比其他存储方式复杂的多的一种存储方式，文件存储有几个关键结点，<code>android 4.4</code>、<code>android 6.0</code>、<code>android 10</code>、<code>android 11</code>之后我们会一一讲到。</p>
</li>
</ul>
<p>　　在学习文件存储之前，我们先要了解文件存储的一些基础知识。</p>
<h3 id="存储是如何划分的？如何访问？"><a href="#存储是如何划分的？如何访问？" class="headerlink" title="存储是如何划分的？如何访问？"></a>存储是如何划分的？如何访问？</h3><p>　　首先明确一点的是android手机的存储空间由两部分构成，分别是内部存储和外部存储。</p>
<p>　　在android 4.4之前，由于当时的技术限制，android手机的自带内存（我们暂且称为内部内存）是非常的小，完全不够用，于是为了扩大存储，我们需要将一张SD卡（Secure Digital Memory Card/SD card）插入手机来扩大存储空间。这部分也就是外部存储，这也是当时开发过程中为什么使用外部存储必须要检查外部存储是否挂载的原因。</p>
<p>　　在android 4.4之后技术突破，手机自带的内存也变得客观。可这部分自带的内存被分为了内部存储和外部存储。但是你仍然可以插入SD卡来扩大你的手机外部存储，不过很快手机厂商就在后续的android手机中移除的SD卡的卡槽。这也就成为后续的存储划分（方框大小不代表实际划分大小）。</p>
<p><img src="https://s2.loli.net/2022/05/29/tzuDNbH4jxZXygC.png" alt="存储划分"></p>
<p>　　需要注意的是<strong>内部存储和外部存储中APP私有空间在APP卸载的时候也会同时删除</strong>，这也是很多APP要在你的外部存储空间的别的地方建立文件夹存文件的原因。APP私有空间的文件不会提供给别的应用访问，属于应用独占。其他目录只要有读写权限都可以访问，但是这在android 10(API 29)中已经做出了较大的改动。接着我们看看<br>手机的内部存储是什么样的结构，</p>
<h4 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h4><p>　　以包名<code>space.lianxin.room</code>和<code>space.lianxin.storage</code>为例，</p>
<p><img src="https://s2.loli.net/2022/05/29/oRv3W8dLF1NOIxG.png" alt="内部存储"></p>
<p>可以看出我们的数据库文件和SharedPreferences文件都存放在/data/data/packageName/下面，部分手机是/data/user/0/packageName/下面。这些文件夹分别存放的数据是：</p>
<blockquote>
<p>cache ==&gt; 存放缓存文件<br>code_cache ==&gt; 存放运行时的一些代码缓存<br>databases ==&gt; 存放数据库文件<br>files ==&gt; 存放文件<br>shared_prefs ==&gt; 存放SharedPreferences 文件</p>
</blockquote>
<p>对于内部存储，我们可以通过<code>context.getCacheDir()</code>、<code>context.getCodeCacheDir()</code>、<code>context.getFileDir()</code>获取到对应的文件夹。</p>
<p>　　既然我们已经知道了如何去获取文件路径，那么接下来我们怎么去保存文件呢？文件的读写方式大致分为<strong>字节流</strong>和<strong>字符流</strong>。这里不赘述了。但是这个流程是一致的：<strong>获取路径 ==&gt; 开启文件流 ==&gt; 读写文件 ==&gt; 关闭流</strong> 。这就是一个完整的文件读写过程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取文件路径并创建文件</span></span><br><span class="line">    <span class="keyword">val</span> file = File(getFilesDir(), <span class="string">&quot;temp.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.createNewFile()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启文件流</span></span><br><span class="line">    <span class="keyword">val</span> fos = FileOutputStream(file)</span><br><span class="line">    <span class="comment">// 写文件</span></span><br><span class="line">    fos.write(<span class="string">&quot;12345&quot;</span>.toByteArray(Charsets.UTF_8))</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    fos.close()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，一个文件就保存好了，而且<strong>不需要任何权限、不需要任何权限、不需要任何权限</strong>。</p>
<h4 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h4><h5 id="APP私有目录"><a href="#APP私有目录" class="headerlink" title="APP私有目录"></a>APP私有目录</h5><p>　　这部分和内部存储基本没什么大的区别。不过是将路径改成了/sdcard/Android/data/packageName/，部分手机是/storage/emulated/0/Android/data/packageName/。获取路径的方式如下：</p>
<blockquote>
<p>context.getExternalCacheDir() // 结果: /sdcard/Android/data/space.lianxin.storage/cache<br>context.getExternalFilesDir(String) // 结果: /sdcard/Android/data/space.lianxin.storage/files</p>
</blockquote>
<p>同样的，这部分存储空间<strong>不需要任何权限，并且在软件卸载时删除</strong>。第二个方法需要一个String参数,其实就是在原本的目录下又创建了一个子文件夹并返回这个子文件夹的路径。(笔者在Android studio上调试的时候发现断点获取到的路径值是/storage/emulated/0/Android/data/packageName/，而实际操作的路径值是/sdcard/Android/data/packageName/。其实这两个路径是同一个值)。</p>
<p>　　别看APP私有目录和内部存储那么像，其差异还是存在的。几点概括就是：</p>
<ul>
<li><p>内部存储用于存储容量较小，私密性强的文件。</p>
</li>
<li><p>APP私有目录用于存储容量较大的文件</p>
</li>
<li><p>两者均APP独占，无需任何权限</p>
</li>
<li><p>APP卸载后，两者存储的数据均会被删除</p>
</li>
<li><p>只有这两个目录下的文件最终会被算到 设置-缓存 中</p>
</li>
<li><p>用户清除缓存时，两者的cache和code_cache文件夹下的文件会被清除</p>
</li>
<li><p>用户清除数据时，两者的所有数据会被清除</p>
</li>
</ul>
<h5 id="公共目录（媒体文件和文档-其它文件）"><a href="#公共目录（媒体文件和文档-其它文件）" class="headerlink" title="公共目录（媒体文件和文档/其它文件）"></a>公共目录（媒体文件和文档/其它文件）</h5><p>　　公共目录<strong>需要存储权限</strong>才能够进行访问，这也是本文介绍的重点。</p>
<h3 id="存储权限"><a href="#存储权限" class="headerlink" title="存储权限"></a>存储权限</h3><p>　　存储权限可以大体的分为三个阶段：第一阶段是android 4.4之前。开发者只需要在清单文件(AndroidManifest.xml)中声明即可，就像这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二个阶段是android 6.0开始，除了需要在清单文件中声明之外，还需要动态的去申请权限。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册存储权限申请</span></span><br><span class="line">    registerPermissionStorage =</span><br><span class="line">    	registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) &#123;</span><br><span class="line">            <span class="comment">// 请求结果的回调</span></span><br><span class="line">            binding.tvDisplay.text = <span class="string">&quot;存储权限获取结果为：<span class="variable">$it</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 发起请求</span></span><br><span class="line">    registerPermissionLocation.launch(</span><br><span class="line">        arrayOf(</span><br><span class="line">            Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">            Manifest.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式（不推荐）</span></span><br><span class="line"><span class="comment">// 先申请权限，然后重写onRequestPermissionsResult方法。</span></span><br><span class="line">ActivityCompat.requestPermissions(</span><br><span class="line">    activity,</span><br><span class="line">    arrayOf(</span><br><span class="line">        Manifest.permission.ACCESS_COARSE_LOCATION,</span><br><span class="line">        Manifest.permission.ACCESS_FINE_LOCATION</span><br><span class="line">    ),</span><br><span class="line">    REQUEST_CODE_STORAGE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>最后一个阶段就是Android 10开始的分区存储。</p>
<h3 id="Android-10之前的访问方式"><a href="#Android-10之前的访问方式" class="headerlink" title="Android 10之前的访问方式"></a>Android 10之前的访问方式</h3><h4 id="媒体文件"><a href="#媒体文件" class="headerlink" title="媒体文件"></a>媒体文件</h4><p>　　访问媒体文件目的还是需要拿到文件的路径，获取文件流。主要的方式有三种方式：</p>
<p>第一种：直接构建路径。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMedia1</span><span class="params">()</span></span>: Bitmap? &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED) &#123;</span><br><span class="line">            <span class="keyword">val</span> path = Environment.getExternalStorageDirectory()</span><br><span class="line">            <span class="keyword">val</span> imgPath = <span class="string">&quot;<span class="subst">$&#123;path&#125;</span><span class="subst">$&#123;File.separator&#125;</span><span class="subst">$&#123;Environment.DIRECTORY_DCIM&#125;</span><span class="subst">$&#123;File.separator&#125;</span>123.jpg&quot;</span></span><br><span class="line">            <span class="keyword">return</span> BitmapFactory.decodeFile(imgPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式：通过<strong>MediaStore</strong>获取路径</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMedia2</span><span class="params">(context: <span class="type">Context</span>)</span></span>: List&lt;Bitmap&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> resolver = context.contentResolver</span><br><span class="line">    <span class="keyword">val</span> cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;Bitmap&gt;()</span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> imgPath = cursor.getStringOrNull(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA))</span><br><span class="line">        imgPath?.let &#123;</span><br><span class="line">            result.add(BitmapFactory.decodeFile(it))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方式：通过<strong>MediaStore</strong>获取Uri，和第二种方法相似。拿到Uri之后再处理就可以获取到媒体文件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = cursor.getLongOrNull(cursor.getColumnIndex(MediaStore.MediaColumns._ID)) ?: <span class="number">0L</span></span><br><span class="line">    <span class="keyword">val</span> uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h4><p>　　其他文件也可以直接构建路径的方式去访问，不赘述了。第二种方式就是打开文件选择器，然后去选择文件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式（不推荐）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)</span><br><span class="line">    	.addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    	.setType(<span class="string">&quot;imaga/jpg&quot;</span>)</span><br><span class="line">    startActivityForResult(intent, <span class="number">201</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">201</span> &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        openUri(<span class="keyword">data</span>.<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过uri构建图片文件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openUri</span><span class="params">(uri: <span class="type">Uri</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uri == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> fis = contentResolver.openInputStream(uri)</span><br><span class="line">        <span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(fis)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">registerForActivityResult(ActivityResultContracts.OpenDocument()) &#123;</span><br><span class="line">    openUri(it)</span><br><span class="line">&#125;.launch(arrayOf(<span class="string">&quot;image/jpg&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>　　直接构建路径，<code>File.mkdirs()</code>创建好文件，然后保存自己的文件。</p>
<h3 id="Android-10变更"><a href="#Android-10变更" class="headerlink" title="Android 10变更"></a>Android 10变更</h3><h4 id="为什么要变更？"><a href="#为什么要变更？" class="headerlink" title="为什么要变更？"></a>为什么要变更？</h4><p>　　在外部存储的文件，不会被统计到 设置-缓存 中去，软件卸载的时候也就不会清除这些垃圾，还有许多软件管杀不管埋（在/sdcard/新建自己的文件夹确实方便操作文件，但是又不去清理），导致手机越用内存越小。同样的，因为谁都可以访问外部存储空间，这样就导致数据不安全。</p>
<h4 id="变更了那些地方？"><a href="#变更了那些地方？" class="headerlink" title="变更了那些地方？"></a>变更了那些地方？</h4><p>　　<strong>外部存储媒体文件、文档和其他目录文件不能使用路径直接访问文件</strong>、而是需要通过Uri访问（也就是内部存储和APP私有空间还是没啥变化）。共享存储空间存放的是图片、视频、音频等文件，这些资源是公用的，所有App都能够访问它们。系统里有external.db数据库，该数据库里有files表，该表里存放着共享文件的诸多信息，如图片有宽高，经纬度、存放路径等，视频宽高、时长、存放路径等。而文件真正存放的地方在于共享存储空间。</p>
<p><strong>现在保存图片到相册</strong>，简单流程如下：</p>
<ol>
<li><p>将路径信息写入数据库里，并获取Uri</p>
</li>
<li><p>通过Uri构造输出流</p>
</li>
<li><p>将该图片保存在/sdcard/Pictures/目录下</p>
</li>
</ol>
<p>从相册<strong>获取图片</strong>，简单流程如下：</p>
<ol>
<li><p>先查询数据库，找到对应的图片Cursor</p>
</li>
<li><p>从Cursor里构造Uri</p>
</li>
<li><p>从Uri构造输入流读取图片</p>
</li>
</ol>
<p>这套流程对音频和视频同样适用。</p>
<h4 id="MediaStore作用"><a href="#MediaStore作用" class="headerlink" title="MediaStore作用"></a>MediaStore作用</h4><p>　　共享存储空间里存放着图片、视频、音频、下载的文件，App获取或者插入文件的时候怎么区分这些类型呢？<br>这个时候就需要MediaStore。MediaStore（Api 29）的结构大致如下。</p>
<blockquote>
<p>MediaStore<br>　　| - Audio<br>　　| - DownloadColumns<br>　　| - Downloads<br>　　| - Files<br>　　| - Images<br>　　| - InternalThumbnails (@Deprecated)<br>　　| - MediaColumns<br>　　| - PendingParams (@Deprecated)<br>　　| - PendingSession (@Deprecated)<br>　　| - ThumbnailConstants<br>　　| - Video</p>
</blockquote>
<p>　　可以看出其内部有Audio、Images等内部类，这些内部类里记录着files表的各个字段名，通过构造这些参数就可以插入相应的字段值以及获取对应的字段值。MediaStore 实际上就是相当于给各个字段起了别名，我们编码的时候更容易记住与使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Audio</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio metadata columns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AudioColumns</span> <span class="keyword">extends</span> <span class="title">MediaColumns</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A non human readable key calculated from the TITLE, used for</span></span><br><span class="line"><span class="comment">         * searching, sorting and grouping</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Column(value = Cursor.FIELD_TYPE_STRING, readOnly = true)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TITLE_KEY = <span class="string">&quot;title_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** <span class="doctag">@removed</span> promoted to parent interface */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DURATION = <span class="string">&quot;duration&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The position within the audio item at which playback should be</span></span><br><span class="line"><span class="comment">         * resumed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@DurationMillisLong</span></span><br><span class="line">        <span class="meta">@Column(Cursor.FIELD_TYPE_INTEGER)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOKMARK = <span class="string">&quot;bookmark&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The id of the artist who created the audio file, if any</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Column(value = Cursor.FIELD_TYPE_INTEGER, readOnly = true)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARTIST_ID = <span class="string">&quot;artist_id&quot;</span>;</span><br><span class="line">        <span class="comment">// ....等等。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MediaStore和Uri联系"><a href="#MediaStore和Uri联系" class="headerlink" title="MediaStore和Uri联系"></a>MediaStore和Uri联系</h4><p><img src="https://s2.loli.net/2022/05/29/mZtQiY7vGLClfIF.png" alt="MediaStore和Uri联系"></p>
<p>比如想要查询共享存储空间里的图片文件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p><code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code> 意思是指定查询文件的类型是图片，并构造成Uri对象，Uri实现了Parcelable，能够在进程间传递。接收方(另一个进程收到后)，匹配Uri，解析出对应的字段，进行具体的操作。当然，MediaStore是系统提供的方便操作共享存储空间的类，若是自己写ContentProvider，则也可以自定义类似MediaStore的类用来标记自己的数据库表的字段。</p>
<h4 id="通过Uri读取和写入文件"><a href="#通过Uri读取和写入文件" class="headerlink" title="通过Uri读取和写入文件"></a>通过Uri读取和写入文件</h4><p>　　既然不能通过路径直接访问文件，那么来看看如何通过Uri访问文件(虽然也可以通过文件路径直接构造Uri，但是此种方式构造的Uri是没有权限访问文件的)。</p>
<ul>
<li><strong>读取文件</strong></li>
</ul>
<p>　　比如说我在<code>/sdcard/mytest.txt</code>有一个文件，如果我们按照之前的写法，会报权限错误；而<code>mytest.txt</code>不属于共享存储空间的文件，是属于其它目录的，因此又不能通过MediaStore获取。我们只能通过SAF获取。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    registerForActivityResult(ActivityResultContracts.OpenDocument()) &#123;</span><br><span class="line">        openUri(it)</span><br><span class="line">    &#125;.launch(arrayOf(<span class="string">&quot;text/plain&quot;</span>))    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openUri</span><span class="params">(uri: <span class="type">Uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inputStream = contentResolver.openInputStream(uri)</span><br><span class="line">        <span class="comment">// 拿到流，做该做的的事咯</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件的读取就没有问题了。</p>
<ul>
<li><strong>写入文件</strong></li>
</ul>
<p>　　写文件和读文件都是差不多的代码。拿到文件流就向文件中写数据。我怎么在这个文件下面创建文件呢？<strong>达咩，达咩，达咩</strong>。</p>
<h4 id="通过Uri-获取图片和插入相册"><a href="#通过Uri-获取图片和插入相册" class="headerlink" title="通过Uri 获取图片和插入相册"></a>通过Uri 获取图片和插入相册</h4><p>　　上面列举出了其它目录下文件的读写，方法是通过SAF拿到Uri。SAF好处是：系统提供了文件选择器，调用者只需要指定想要读写的文件类型，比如文本类型、图片类型、视频类型等，选择器就会过滤出相应文件以供选择。接入方便，选择简单。</p>
<p>　　但是如果需要自己实现相册选择器，那么就需要获得共享存储空间下的文件信息。此种场景下使用SAF是无法做到的。因此问题的关键是：<strong>如何批量获得共享存储空间下图片/视频的信息？</strong>答案是：ContentResolver+ContentProvider+MediaStore(ContentProvider对于调用者是透明的)。<br>以图片为例，分析插入与查询方式。</p>
<ul>
<li><strong>插入相册</strong></li>
</ul>
<p>　　图片插入相册的完整流程如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertPic</span><span class="params">(inputStream: <span class="type">InputStream</span>, fileName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> values = ContentValues()</span><br><span class="line">    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME, fileName)</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        values.put(MediaStore.Images.ImageColumns.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> path = Environment.getExternalStorageState() +</span><br><span class="line">        	File.separator + Environment.DIRECTORY_PICTURES +</span><br><span class="line">        	File.separator + fileName</span><br><span class="line">        <span class="comment">// MediaStore.Images.ImageColumns.DATA已经废弃了。</span></span><br><span class="line">        values.put(MediaStore.Images.ImageColumns.DATA, path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入相册</span></span><br><span class="line">    <span class="keyword">val</span> uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    writeFile(uri, inputStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeFile</span><span class="params">(uri: <span class="type">Uri</span>?, inputStream: <span class="type">InputStream</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> outputStream = contentResolver.openOutputStream(uri)</span><br><span class="line">        <span class="comment">// 拿到写入流，该干啥干啥。</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里有几处需要说明。</p>
<p>　　第一：Android 10.0之前，<code>MediaStore.Images.ImageColumns.DATA</code> 字段记录的是图片的<strong>绝对路径</strong>，而Android 10.0(含)之后，DATA 被废弃，取而代之的是使用<code>MediaStore.Images.ImageColumns.RELATIVE_PATH</code>，表示<strong>相对路径</strong>。比如指定RELATIVE_PATH为Environment.DIRECTORY_PICTURES，表示之后的图片将会放到Environment.DIRECTORY_PICTURES目录下。　　　　　　</p>
<p>　　第二：调用ContentResolver里的方法插入相册。<code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code> 指的是插入图片表。ContentValues 以Map的形式记录了待写入的字段值。插入后返回Uri。</p>
<p>　　第三：以上两步仅仅只是往数据库里增加一条记录，该记录指向的新文件是空的，需要将图片写入到新文件。而新文件位于<code>/sdcard/Pictures/</code>目录下，该目录是不能直接通过路径访问的，因此需要通过第二步返回的Uri进行访问。</p>
<ul>
<li><strong>获取图片</strong></li>
</ul>
<p>　　获取图片现在只能通过之前讲到的通过<code>MediaStore</code>去获取Uri，再构建文件流，从流中读取文件。</p>
<p>　　以上，通过Uri 获取图片和插入相册分析完毕，共享存储空间的其他文件类型如视频、音频、下载文件也是同样的流程。</p>
<h3 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h3><p>　　通过Uri访问文件似乎已经满足了Android 10.0适配要求，但是仔细想想还是有不足之处：</p>
<ul>
<li>共享存储空间只能通过MediaStore访问，以前流行的访问方式是直接通过路径访问。比如自己做的相册管理器，先遍历相册拿到图片/视频的路径，然后再解析成Bitmap展示，现在需要先拿到Uri，再解析成Bitmap，多少有些不方便。此外，也许你依赖的第三方库是直接通过路径访问文件的，而三方库又没有及时更新适配分区存储，可能就会导致用不了相应的功能。</li>
<li>SAF虽然能够访问其它目录的文件，但是每次都需要跳转到新的页面去选择，当想要批量展示文件的时候，比如自己做的文件管理器，就需要列出当前目录下有哪些目录/文件，这个时候需要有权限遍历/sdcard/目录。显然，SAF并不能胜任此工作。</li>
</ul>
<p>Android 11.0考虑到上面的问题，因此做了新的优化。</p>
<h4 id="共享存储空间-媒体文件访问变更"><a href="#共享存储空间-媒体文件访问变更" class="headerlink" title="共享存储空间-媒体文件访问变更"></a>共享存储空间-媒体文件访问变更</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getImagePath</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA)</span><br><span class="line">            <span class="keyword">val</span> path = cursor.getString(index)</span><br><span class="line">            <span class="keyword">val</span> bitmap = BitmapFactory.decodeFile(path)</span><br><span class="line">            <span class="comment">// 图片操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　可以看出，之前在Android 10.0上被禁用的访问方式，在Android 11.0上又被允许了，这就解决了上面的第一个问题。需要注意的是：此种方式只允许读文件，<strong>写文件依然不行</strong>。</p>
<blockquote>
<p>Google 官方指导意见是：虽然可以通过路径直接访问媒体文件，但是这些操作最终是被重定向到MediaStore API的，重定向过程可能会损耗一些性能，并且直接通过路径访问不一定比MediaStore API 访问快。总之建议非必要的话不要直接使用路径访问。</p>
</blockquote>
<h4 id="访问所有文件"><a href="#访问所有文件" class="headerlink" title="访问所有文件"></a>访问所有文件</h4><p>　　假若App开启了分区存储功能，当App运行在Android 10.0的设备上时，是没法遍历/sdcard/目录的。而在Android 11.0上运行时是可以遍历的，需要进行如下几个步骤。</p>
<ol>
<li>在AndroidManifest.xml添加权限声明</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>动态申请权限（这里申请的不是弹框告知，而是跳到了新的界面，由用户开启）</li>
<li>这样就可以像android之前一样去读写文件了。</li>
</ol>
<p>另外有一点如果android 10想想android 10之前一样访问文件，只需要在清单文件的<code>application</code>下加上</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:requestLegacyExternalStorage=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到这里文件存储适配就讲完了，变动简单来说就是不能再使用绝对路径去访问文件，没有授权的文件区域，也不在提供读写权限。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingyizhuyin@qq.com">恋心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lianxin.space/2022/05/29/Storage/">http://lianxin.space/2022/05/29/Storage/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lianxin.space" target="_blank">恋心</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/">持久化</a><a class="post-meta__tags" href="/tags/%E9%80%82%E9%85%8D/">适配</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/01/Maven/"><img class="prev-cover" src="https://s2.loli.net/2023/02/01/GleXN9iacd1HvRE.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用maven-publish发布aar包到maven仓库</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/20/EventBus/"><img class="next-cover" src="https://i.loli.net/2021/06/20/41S3zHA5RdfTgju.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">EventBus使用并手撸核心源码</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/02/26/6htEVf4X7aIqLxk.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">恋心</div><div class="author-info__description">稳　稳　的　幸　福</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lianxin0119"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">QQ：43450340</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">存储是如何划分的？如何访问？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">内部存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.</span> <span class="toc-text">外部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#APP%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">APP私有目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%9B%AE%E5%BD%95%EF%BC%88%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%A1%A3-%E5%85%B6%E5%AE%83%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">公共目录（媒体文件和文档&#x2F;其它文件）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9D%83%E9%99%90"><span class="toc-number">3.</span> <span class="toc-text">存储权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-10%E4%B9%8B%E5%89%8D%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">Android 10之前的访问方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">媒体文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">其他文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">创建文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-10%E5%8F%98%E6%9B%B4"><span class="toc-number">5.</span> <span class="toc-text">Android 10变更</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%98%E6%9B%B4%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">为什么要变更？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%E4%BA%86%E9%82%A3%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">变更了那些地方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MediaStore%E4%BD%9C%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">MediaStore作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MediaStore%E5%92%8CUri%E8%81%94%E7%B3%BB"><span class="toc-number">5.4.</span> <span class="toc-text">MediaStore和Uri联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Uri%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">5.5.</span> <span class="toc-text">通过Uri读取和写入文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Uri-%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E5%92%8C%E6%8F%92%E5%85%A5%E7%9B%B8%E5%86%8C"><span class="toc-number">5.6.</span> <span class="toc-text">通过Uri 获取图片和插入相册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-11"><span class="toc-number">6.</span> <span class="toc-text">Android 11</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4-%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8F%98%E6%9B%B4"><span class="toc-number">6.1.</span> <span class="toc-text">共享存储空间-媒体文件访问变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">访问所有文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/Maven/" title="使用maven-publish发布aar包到maven仓库"><img src="https://s2.loli.net/2023/02/01/GleXN9iacd1HvRE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用maven-publish发布aar包到maven仓库"/></a><div class="content"><a class="title" href="/2023/02/01/Maven/" title="使用maven-publish发布aar包到maven仓库">使用maven-publish发布aar包到maven仓库</a><time datetime="2023-02-01T10:43:46.000Z" title="发表于 2023-02-01 18:43:46">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/Storage/" title="Android存储"><img src="https://s2.loli.net/2022/05/29/T9c6nAC2rbyLHx1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android存储"/></a><div class="content"><a class="title" href="/2022/05/29/Storage/" title="Android存储">Android存储</a><time datetime="2022-05-29T01:44:00.000Z" title="发表于 2022-05-29 09:44:00">2022-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/20/EventBus/" title="EventBus使用并手撸核心源码"><img src="https://i.loli.net/2021/06/20/41S3zHA5RdfTgju.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EventBus使用并手撸核心源码"/></a><div class="content"><a class="title" href="/2021/06/20/EventBus/" title="EventBus使用并手撸核心源码">EventBus使用并手撸核心源码</a><time datetime="2021-06-20T02:28:00.000Z" title="发表于 2021-06-20 10:28:00">2021-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/06/room/" title="使用Room数据持久化"><img src="https://i.loli.net/2021/05/04/yUq8u6AOziwmcWd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Room数据持久化"/></a><div class="content"><a class="title" href="/2021/04/06/room/" title="使用Room数据持久化">使用Room数据持久化</a><time datetime="2021-04-06T06:19:03.000Z" title="发表于 2021-04-06 14:19:03">2021-04-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/05/29/T9c6nAC2rbyLHx1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 恋心</div><div class="footer_custom_text">逆水行舟 不进则退</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>